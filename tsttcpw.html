

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>The Simplest(?) Thing That Could Possibly Work for subtyping &mdash; JSpecify  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="JSpecify: Standard Java annotations for static analysis" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> JSpecify
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Simplest(?) Thing That Could Possibly Work for subtyping</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#references-to-concepts-defined-by-this-spec">References to concepts defined by this spec</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-operator">Nullness operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type">Augmented type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#null-aware-context">Null-aware context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-a-type-usage-appearing-in-code">Augmented type of a type usage appearing in code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-an-intersection-type">Augmented type of an intersection type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-unbounded-wildcard">Bound of an “unbounded” wildcard</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-object-bounded-type-parameter">Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-null-types">Augmented null types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-least-convenient-world-and-the-most-convenient-world">The least convenient world and the most convenient world</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#propagating-the-most-least-convenient-world">Propagating the most/least convenient world</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#same-type">Same type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subtyping">Subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-delegating-subtyping-rules-for-java">Nullness-delegating subtyping rules for Java</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtyping">Nullness subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trusted-null-inclusive-under-every-parameterization">Trusted null-inclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trusted-null-exclusive-under-every-parameterization">Trusted null-exclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-path">Nullness-subtype-establishing path</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-direct-supertype-edges">Nullness-subtype-establishing direct-supertype edges</a></li>
<li class="toctree-l2"><a class="reference internal" href="#containment">Containment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#substitution">Substitution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#applying-a-nullness-operator-to-an-augmented-type">Applying a nullness operator to an augmented type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capture-conversion">Capture conversion</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">JSpecify</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>The Simplest(?) Thing That Could Possibly Work for subtyping</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/tsttcpw.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-simplest-thing-that-could-possibly-work-for-subtyping">
<h1>The Simplest(?) Thing That Could Possibly Work for subtyping<a class="headerlink" href="#the-simplest-thing-that-could-possibly-work-for-subtyping" title="Permalink to this headline">¶</a></h1>
<p><strong>This is not “the JSpecify spec.” This is an initial attempt to
formally specify only a subset of the rules we’ll need for a subset of
features we wish to cover. Additionally, it deviates from some of our
current working decisions in an effort to remain simple.</strong></p>
<blockquote>
<div><p class="rubric" id="high-level-overview">High-level overview</p>
<p>It may be that some people will use this doc to guide their
implementations in the near future. Please don’t hesitate to let
cpovirk know of any confusing bits.</p>
<p>I should probably preemptively clarify at least one thing. In this
doc, I have tried to distinguish explicitly between 3 “kinds of
nullability” of a given type usage. Each kind is derived (at least in
part) from the previous:</p>
<ol class="arabic simple">
<li><p>What annotation (if any) appears directly on that type usage?</p></li>
<li><p>What is the <a class="reference external" href="#nullness-operator">nullness operator</a> of that
type usage?</p></li>
<li><p>For that type usage…</p>
<ul class="simple">
<li><p>Is it safe to assume that is not <code class="docutils literal notranslate"><span class="pre">null</span></code>?</p></li>
<li><p>Is it safe to put a <code class="docutils literal notranslate"><span class="pre">null</span></code> into it?</p></li>
<li><p>neither (as in “parametric nullness”)</p></li>
<li><p>both (as in “unspecified nullness” in “lenient mode”)</p></li>
</ul>
</li>
</ol>
<p>TODO(cpovirk): Link to my “Don’t say ‘nullable’” doc once I write it.</p>
</div></blockquote>
<div class="section" id="references-to-concepts-defined-by-this-spec">
<span id="concept-references"></span><h2>References to concepts defined by this spec<a class="headerlink" href="#references-to-concepts-defined-by-this-spec" title="Permalink to this headline">¶</a></h2>
<p>When a rule in this spec refers to any concept that is defined in this
spec (for example, <a class="reference external" href="#substitution">substitution</a> or
<a class="reference external" href="#containment">containment</a>), apply this spec’s definition (as
opposed to other definitions, such as the ones in the JLS).</p>
<p>Additionally, when a rule in this spec refers to a JLS rule that in turn
refers to a concept that is defined in this spec, likewise apply this
spec’s definition.</p>
<p>In particular, when a JLS rule refers to types, apply this spec’s
definition of <a class="reference external" href="#augmented-type">augmented types</a> (as oppposed to
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
types</a>).</p>
</div>
<div class="section" id="nullness-operator">
<h2>Nullness operator<a class="headerlink" href="#nullness-operator" title="Permalink to this headline">¶</a></h2>
<p>An nullness operator is one of 4 values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
</ul>
<blockquote>
<div><p>The distinction among these 4 values is similar to the distinction
among the Kotlin types <code class="docutils literal notranslate"><span class="pre">Foo?</span></code>, <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, <code class="docutils literal notranslate"><span class="pre">Foo!</span></code>, and <code class="docutils literal notranslate"><span class="pre">Foo!!</span></code>,
respectively.</p>
</div></blockquote>
</div>
<div class="section" id="augmented-type">
<h2>Augmented type<a class="headerlink" href="#augmented-type" title="Permalink to this headline">¶</a></h2>
<p>An augmented type consists of a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
and a <a class="reference external" href="#nullness-operator">nullness operator</a> corresponding to <em>each</em>
of its <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.g7gl9fwq1tt5">type
components</a>.</p>
<blockquote>
<div><p>This differs from our current <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.367l48xhsikk">glossary
definition</a>,
which is written in terms of a “nullness” for each component, not a
“nullness operator.” Still, the glossary’s concept of the “nullness”
of a type is derivable from the type’s nullness operator. Notably,
the glossary’s “nullable” type is our <a class="reference external" href="#multiple-worlds">least convenient
world</a>’s <a class="reference external" href="#trusted-null-inclusive-under-every-parameterization">trusted null-inclusive under every
parameterization</a>,
and the glossary’s “non-nullable” type is our least convenient
world’s <a class="reference external" href="#trusted-null-exclusive-under-every-parameterization">trusted null-exclusive under every
parameterization</a>.</p>
</div></blockquote>
<p>For our purposes, base types (and thus augmented types) include not just
class and interface types, array types, and type variables but also
<a class="reference external" href="#intersection-types">intersection types</a> and the null type. This is
true even though the JLS sometimes does not supply rules for
intersection types and sometimes has separate rules for the null type.</p>
<p>The goal of this spec is to define rules for augmented types compatible
with those that the JLS defines for base types.</p>
<blockquote>
<div><p>In almost all cases, this spec agrees with the JLS’s rules when
specifying what <em>base</em> types appear in a piece of code. It makes an
exception for <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded
wildcard,”</a> for which it specifies a bound of
<code class="docutils literal notranslate"><span class="pre">Object</span></code> that the JLS does not specify.</p>
</div></blockquote>
<p>When this spec uses capital letters, they refer to augmented types
(unless otherwise noted). This is in contrast to the JLS, which
typically uses them to refer to base types.</p>
<p>When this spec refers to “the nullness operator of” a type <code class="docutils literal notranslate"><span class="pre">T</span></code>, it
refers specifically to the nullness operator of the type component that
is the entire type <code class="docutils literal notranslate"><span class="pre">T</span></code>, without reference to the nullness operator of
any other type components of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<blockquote>
<div><p>For example, the nullness operator of <code class="docutils literal notranslate"><span class="pre">List&lt;&#64;Nullable</span> <span class="pre">Object&gt;</span></code>
would be <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> (at least in a <a class="reference external" href="#null-aware-context">null-aware
context</a>), even though the nullness operator
of its element type <code class="docutils literal notranslate"><span class="pre">Object</span></code> is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="null-aware-context">
<h2>Null-aware context<a class="headerlink" href="#null-aware-context" title="Permalink to this headline">¶</a></h2>
<p>To determine whether a type usage appears in a null-aware context:</p>
<p>Look for an <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.annotations.NullAware</span></code> annotation on any of
the enclosing scopes surrounding the type usage.</p>
<p>Class members are enclosed by classes, which may be enclosed by other
class members or classes. and top-level classes are enclosed by
packages, which may be enclosed by modules.</p>
<blockquote>
<div><p>Packages are <em>not</em> enclosed by “parent” packages.</p>
</div></blockquote>
<blockquote>
<div><p>This definition of “enclosing” likely matches <a class="reference external" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.compiler/javax/lang/model/element/Element.html#getEnclosingElement()">the definition in the
Java compiler
API</a>.</p>
</div></blockquote>
<p>If an <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.annotations.NullAware</span></code> annotation exists on one
of these scopes, then the type usage is in a null-aware context.
Otherwise, it is not.</p>
</div>
<div class="section" id="augmented-type-of-a-type-usage-appearing-in-code">
<span id="augmented-type-of-usage"></span><h2>Augmented type of a type usage appearing in code<a class="headerlink" href="#augmented-type-of-a-type-usage-appearing-in-code" title="Permalink to this headline">¶</a></h2>
<p>For most type usages in source code or bytecode on which JSpecify
nullness annotations are structurally valid, this section defines how to
determine their <a class="reference external" href="#augmented-type">augmented types</a>. Note, however,
that rules for specific cases below take precedence over the general
rule here.</p>
<p>Because the JLS already has rules for determining the <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
for a type usage, this section covers only how to determine its
<a class="reference external" href="#nullness-operator">nullness operator</a>.</p>
<p>To determine the nullness operator, apply the following rules in order.
Once one condition is met, skip the remaining conditions.</p>
<ul class="simple">
<li><p>If the type usage is annotated with
<code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.annotations.Nullable</span></code>, its nullness operator is
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If the type usage appears in a <a class="reference external" href="#null-aware-context">null-aware
context</a>, its nullness operator is
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
<li><p>Its nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p></li>
</ul>
<blockquote>
<div><p>The choice of nullness operator is <em>not</em> affected by any nullness
operator that appears in a corresponding location in a supertype. For
example, if one type declares a method whose return type is annotated
<code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>, and if another type overrides that method but does not
declare the return type as <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>, then the override’s return
type will <em>not</em> have nullness operator <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
<p>The rules here never produce the fourth nullness operator,
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>. (It will appear later in
<a class="reference external" href="#substitution">substitution</a>. Additionally, we expect for tool
authors to produce <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> based on the results of null checks
in implementation code.) However, if tool authors prefer, they can
safely produce <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> in any case in which it is equivalent
to <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>. For example, there is no difference between a
<code class="docutils literal notranslate"><span class="pre">String</span></code> with <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> and a <code class="docutils literal notranslate"><span class="pre">String</span></code> with <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="augmented-type-of-an-intersection-type">
<span id="intersection-types"></span><h2>Augmented type of an intersection type<a class="headerlink" href="#augmented-type-of-an-intersection-type" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Technically speaking, the JLS does not define syntax for an
intersection type. Instead, it defines a syntax for type parameters
and casts that supports multiple types. Then the intersection type is
derived from those. Intersection types can also arise from operations
like <a class="reference external" href="#capture-conversion">capture conversion</a>. See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.9">JLS
4.9</a>.</p>
<p>One result of all this is that it’s never possible for a programmer
to write an annotation “on an intersection type.”</p>
</div></blockquote>
<p>This spec assigns a <a class="reference external" href="#nullness-operator">nullness operator</a> to each
individual element of an intersection type, following our normal rules
for type usages. It also assigns a nullness operator to the intersection
type as a whole. The nullness operator of the type as a whole is always
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>This lets us provide, for every <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>,
a rule for computing its <a class="reference external" href="#augmented-type">augmented type</a>. But we
require <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> so as to avoid questions like whether “a
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> intersection type whose members are <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>
<code class="docutils literal notranslate"><span class="pre">Foo</span></code> and <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> <code class="docutils literal notranslate"><span class="pre">Bar</span></code>” is a subtype of “a <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>
intersection type with those same members.” Plus, it would be
difficult for tools to output the nullness operator of an
intersection type in a human-readable way.</p>
</div></blockquote>
<blockquote>
<div><p>To avoid ever creating an intersection type with a nullness operator
other than <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, we define special handling for intersection
types under <a class="reference external" href="#applying-operator">“Applying a nullness operator to an augmented
type.”</a></p>
</div></blockquote>
</div>
<div class="section" id="bound-of-an-unbounded-wildcard">
<span id="unbounded-wildcard"></span><h2>Bound of an “unbounded” wildcard<a class="headerlink" href="#bound-of-an-unbounded-wildcard" title="Permalink to this headline">¶</a></h2>
<p>In source, an unbounded wildcard is written as <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. This section
does <strong>not</strong> apply to <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, even though that is often
equivalent to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS
4.5.1</a>.</p>
<p>In bytecode, such a wildcard is represented as a wildcard type with an
empty list of upper bounds and an empty list of lower bounds. This
section does <strong>not</strong> apply to a wildcard with any bounds in either list,
even a sole upper bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code>.</p>
<blockquote>
<div><p>For a wildcard with an explicit bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code> (that is,
<code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, perhaps with an annotation on <code class="docutils literal notranslate"><span class="pre">Object</span></code>),
instead apply <a class="reference external" href="#augmented-type-of-usage">the normal rules</a> for the
explicit bound type.</p>
</div></blockquote>
<p>If an unbounded wildcard appears in a <a class="reference external" href="#null-aware-context">null-aware
context</a>, then it has a single upper bound whose
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose <a class="reference external" href="#nullness-operator">nullness operator</a> is
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
<p>If an unbounded wildcard appears outside a null-aware context, then it
has a single upper bound whose base type is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose
nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p>
<blockquote>
<div><p>In both cases, we specify a bound that does not exist in the source
or bytecode, deviating from the JLS. Because the base type of the
bound is <code class="docutils literal notranslate"><span class="pre">Object</span></code>, this should produce no user-visible differences
except to tools that implement JSpecify nullness analysis.</p>
</div></blockquote>
<p>Whenever a JLS rule refers specifically to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>, disregard it, and
instead apply the rules for <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">T&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> has a base
type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and the nullness operator defined by this section.</p>
</div>
<div class="section" id="bound-of-an-object-bounded-type-parameter">
<span id="object-bounded-type-parameter"></span><h2>Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter<a class="headerlink" href="#bound-of-an-object-bounded-type-parameter" title="Permalink to this headline">¶</a></h2>
<p>In source, an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter can be writen in either
of 2 ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> with no JSpecify nullness type annotations on
the bound</p></li>
</ul>
<p>See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">JLS
4.4</a>.</p>
<p>In bytecode, <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> are both represented as
a type parameter with only a single upper bound, <code class="docutils literal notranslate"><span class="pre">Object</span></code>, and no
JSpecify nullness type annotations on the bound.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears in a <a class="reference external" href="#null-aware-context">null-aware
context</a>, then its bound has a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and a <a class="reference external" href="#nullness-operator">nullness operator</a> of
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>Note that this gives <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> a different bound than <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code> (though
only in a null-aware context).</p>
</div></blockquote>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears outside a null-aware
context, then its bound has a base type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and a nullness
operator of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p>
<blockquote>
<div><p>All these rules match the behavior of <a class="reference external" href="#augmented-type-of-usage">our normal
rules</a> for determining the <a class="reference external" href="#augmented-type">augmented
type</a> of the bound <code class="docutils literal notranslate"><span class="pre">Object</span></code>. The only “special”
part is that we consider the source code <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> to have a bound of
<code class="docutils literal notranslate"><span class="pre">Object</span></code>, just as it does when compiled to bytecode.</p>
</div></blockquote>
</div>
<div class="section" id="augmented-null-types">
<span id="null-types"></span><h2>Augmented null types<a class="headerlink" href="#augmented-null-types" title="Permalink to this headline">¶</a></h2>
<p>The JLS refers to “the null type.” In this spec, we assign a <a class="reference external" href="#nullness-operator">nullness
operator</a> to all types, including the null type.
This produces multiple null types:</p>
<ul>
<li><p>the null <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
with nullness operator <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: the “bottom”/“nothing” type
used in <a class="reference external" href="#capture-conversion">capture conversion</a></p>
<blockquote>
<div><p>No value, including <code class="docutils literal notranslate"><span class="pre">null</span></code> itself, has this type.</p>
</div></blockquote>
</li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p>
<blockquote>
<div><p>This is equivalent to the previous type. Tools may use the 2
interchangeably.</p>
</div></blockquote>
</li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>: the type of
the null reference</p></li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code></p>
<blockquote>
<div><p>This may be relevant only in implementation code.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="the-least-convenient-world-and-the-most-convenient-world">
<span id="multiple-worlds"></span><h2>The least convenient world and the most convenient world<a class="headerlink" href="#the-least-convenient-world-and-the-most-convenient-world" title="Permalink to this headline">¶</a></h2>
<p>Some of the rules in this spec come in 2 versions, 1 for “the least
convenient world” and 1 for “the most convenient world.”</p>
<p>Tools may implement either or both versions of the rules.</p>
<blockquote>
<div><p>Our goal is to allow tools and their users to choose their desired
level of strictness in the presence of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>. “The least
convenient world” usually assumes that types are incompatible unless
it has enough information to prove they are compatible; “the most
convenient world” assumes that types are compatible unless it has
enough information to prove they are incompatible.</p>
<p>Thus, strict tools may want to implement the least-convenient-world
version of rules, and lenient tools may wish to implement the
most-convenient-world version. Or a tool might implement both and let
users select which rules to apply.</p>
<p>Another possibility is for a tool to implement both versions and to
use that to distinguish between “errors” and “warnings.” Such a tool
might run each check first in the least convenient world and then, if
the check fails, run it again in the most convenient world. If the
check fails in both worlds, the tool would produce an error. If it
passes only because of the most convenient interpretation, the tool
would produce a warning.</p>
</div></blockquote>
<p>The main body of each section describes the <em>least</em>-convenient-world
rule. If the most-convenient-world rule differs, the differences are
explained at the end.</p>
<div class="section" id="propagating-the-most-least-convenient-world">
<span id="propagating-multiple-worlds"></span><h3>Propagating the most/least convenient world<a class="headerlink" href="#propagating-the-most-least-convenient-world" title="Permalink to this headline">¶</a></h3>
<p>When one rule in this spec refers to another, it refers to the rule for
the same “world.” For example, when the rules for
<a class="reference external" href="#containment">containment</a> refer to the rules for
<a class="reference external" href="#subtyping">subtyping</a>, the most-convenient-world containment check
applies the most-convenient-world subtyping check, and the
least-convenient-world containment check applies the
least-convenient-world subtyping check.</p>
<p>This applies even if a rule says it is the same for both worlds: It
means “the same except that any other rules are applied in the
corresponding world.”</p>
</div>
</div>
<div class="section" id="same-type">
<h2>Same type<a class="headerlink" href="#same-type" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> are the same type if <code class="docutils literal notranslate"><span class="pre">S</span></code> is a <a class="reference external" href="#subtyping">subtype</a>
of <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</div>
<div class="section" id="subtyping">
<h2>Subtyping<a class="headerlink" href="#subtyping" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the following conditions are met:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> according to the <a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating
subtyping rules for Java</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a <a class="reference external" href="#nullness-subtyping">nullness subtype</a> of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
</ul>
</div>
<div class="section" id="nullness-delegating-subtyping-rules-for-java">
<span id="nullness-delegating-subtyping"></span><h2>Nullness-delegating subtyping rules for Java<a class="headerlink" href="#nullness-delegating-subtyping-rules-for-java" title="Permalink to this headline">¶</a></h2>
<p>The Java subtyping rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10">JLS
4.10</a>.
We add to them as follows:</p>
<ul>
<li><p><a class="reference external" href="#concept-references">As always</a>, interpret the Java rules as
operating on <a class="reference external" href="#augmented-type">augmented types</a>, not <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
types</a>.
However, when applying the Java direct-supertype rules themselves,
<em>ignore</em> the <a class="reference external" href="#nullness-operator">nullness operator</a> of the input
types and output types. The augmented types matter only when the Java
rules refer to <em>other</em> rules that are defined in this spec. <em>Those</em>
rules respect the nullness operator of some type components — but
never the nullness operator of the type component that represents the
whole input or output type.</p>
<blockquote>
<div><p>To “ignore” the output’s nullness operator, we recommend
outputting a value of <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, since that is valid for all
types, including <a class="reference external" href="#intersection-types">intersection types</a>.</p>
</div></blockquote>
</li>
<li><p>When the Java array rules require one type to be a <em>direct</em> supertype
of another, consider the direct supertypes of <code class="docutils literal notranslate"><span class="pre">T</span></code> to be <em>every</em>
type that <code class="docutils literal notranslate"><span class="pre">T</span></code> is a <a class="reference external" href="#subtyping">subtype</a> of (as always, applying
the definition of subtyping in this spec).</p></li>
</ul>
</div>
<div class="section" id="nullness-subtyping">
<h2>Nullness subtyping<a class="headerlink" href="#nullness-subtyping" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The primary complication in subtyping comes from type-variable
usages. Our rules for them must account for every combination of type
arguments with which a given generic type can be parameterized.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a nullness subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if any of the following conditions
are met:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> is <a class="reference external" href="#trusted-null-inclusive-under-every-parameterization">trusted null-inclusive under every
parameterization</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is <a class="reference external" href="#trusted-null-exclusive-under-every-parameterization">trusted null-exclusive under every
parameterization</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a <a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing
path</a> to any type whose base
type is the same as the base type of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
</ul>
<p>Nullness subtyping (and thus subtyping itself) is <em>not</em> transitive.</p>
<p>(Contrast this with our <a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating
subtyping</a> rules and
<a class="reference external" href="#containment">containment</a> rules: Each of those is defined as a
transitive closure. However, technically speaking, <a class="reference external" href="https://groups.google.com/d/msg/jspecify-dev/yPnkx_GSb0Q/hLgS_431AQAJ">there are cases in
which those should not be transitive,
either</a>.
Fortunately, this “mostly transitive” behavior is exactly the behavior
that implementations are likely to produce naturally. Maybe someday we
will find a way to specify this fully correctly.)</p>
<p>Nullness subtyping (and thus subtyping itself) is <em>not</em> reflexive.</p>
<blockquote>
<div><p>It does end up being reflexive in the <a class="reference external" href="#multiple-worlds">most convenient
world</a>. We don’t state that as a rule for 2
reasons: First, it arises naturally from the definitions in that
world. Second, we don’t want to suggest that subtyping is reflexive
in the <a class="reference external" href="#multiple-worlds">least convenient world</a>.</p>
</div></blockquote>
</div>
<div class="section" id="trusted-null-inclusive-under-every-parameterization">
<h2>Trusted null-inclusive under every parameterization<a class="headerlink" href="#trusted-null-inclusive-under-every-parameterization" title="Permalink to this headline">¶</a></h2>
<p>A type is trusted null-inclusive under every parameterization if it
meets either of the following conditions:</p>
<ul class="simple">
<li><p>Its <a class="reference external" href="#nullness-operator">nullness operator</a> is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>It is an <a class="reference external" href="#intersection-types">intersection type</a> whose elements
all are trusted null-inclusive under every parameterization.</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rule is the same except that the
requirement for “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>” is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="trusted-null-exclusive-under-every-parameterization">
<h2>Trusted null-exclusive under every parameterization<a class="headerlink" href="#trusted-null-exclusive-under-every-parameterization" title="Permalink to this headline">¶</a></h2>
<p>A type is trusted null-exclusive under every parameterization if it has
a <a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing
path</a> to either of the
following:</p>
<ul>
<li><p>any type whose <a class="reference external" href="#nullness-operator">nullness operator</a> is
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>any augmented class or array type</p>
<blockquote>
<div><p>This rule refers specifically to a “class or array type,” as
distinct from other types like type variables and <a class="reference external" href="#intersection-types">intersection
types</a>.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="nullness-subtype-establishing-path">
<h2>Nullness-subtype-establishing path<a class="headerlink" href="#nullness-subtype-establishing-path" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a nullness-subtype-establishing path to <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the
following hold:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has <a class="reference external" href="#nullness-operator">nullness operator</a> <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p></li>
<li><p>There is a path from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">F</span></code> through
<a class="reference external" href="#nullness-subtype-establishing-direct-supertype-edges">nullness-subtype-establishing direct-supertype
edges</a>.</p>
<blockquote>
<div><p>The path may be empty. That is, <code class="docutils literal notranslate"><span class="pre">A</span></code> has a
nullness-subtype-establishing path to itself — as long as it has
one of the required nullness operators.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirement for “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>” is loosened to
“<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, or <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="nullness-subtype-establishing-direct-supertype-edges">
<h2>Nullness-subtype-establishing direct-supertype edges<a class="headerlink" href="#nullness-subtype-establishing-direct-supertype-edges" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> has nullness-subtype-establishing direct-supertype edges to the
union of the nodes computed by the following 2 rules:</p>
<p>Upper-bound rule:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented <a class="reference external" href="#intersection-types">intersection type</a>:
all the intersection type’s elements whose <a class="reference external" href="#nullness-operator">nullness
operator</a> is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented type variable: all the corresponding type
parameter’s upper bounds whose nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>otherwise: no nodes</p></li>
</ul>
<p>Lower-bound rule:</p>
<ul>
<li><p>for every type parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> that has a lower bound whose <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is the same as <code class="docutils literal notranslate"><span class="pre">T</span></code>’s base type and whose nullness operator is
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: the type variable <code class="docutils literal notranslate"><span class="pre">P</span></code></p>
<p>TODO(cpovirk): What if the lower bound has some other nullness
operator? I’m pretty sure that we want to allow <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> in
the most convenient world (as we did before my recent edits), and we
may want to allow more.</p>
</li>
<li><p>otherwise: no nodes</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirements for “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>” are loosened to
“<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, or <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="containment">
<h2>Containment<a class="headerlink" href="#containment" title="Permalink to this headline">¶</a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS
4.5.1</a>.
We add to them as follows:</p>
<ul>
<li><p>Disregard the 2 rules that refer to a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>. Instead, treat
<code class="docutils literal notranslate"><span class="pre">?</span></code> like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#nullness-operator">nullness
operator</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is specified
by <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>
like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>The rule written specifically for <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code> applies only
if the nullness operator of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>When the JLS refers to the same type <code class="docutils literal notranslate"><span class="pre">T</span></code> on both sides of a rule,
the rule applies if and only if this spec defines the 2 types to be
the <a class="reference external" href="#same-type">same type</a>.</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirement for “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>” is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="substitution">
<h2>Substitution<a class="headerlink" href="#substitution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Substitution on Java base types barely requires an explanation: See
<a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-1.html#jls-1.3">JLS
1.3</a>.
Substitution on <a class="reference external" href="#augmented-type">augmented types</a>, however, is
trickier: If <code class="docutils literal notranslate"><span class="pre">Map.get</span></code> returns “<code class="docutils literal notranslate"><span class="pre">V</span></code> with <a class="reference external" href="#nullness-operator">nullness
operator</a> <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>,” and if a user has a
map whose value type is “<code class="docutils literal notranslate"><span class="pre">String</span></code> with nullness operator
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>,” then what does its <code class="docutils literal notranslate"><span class="pre">get</span></code> method return? Naive
substitution would produce “<code class="docutils literal notranslate"><span class="pre">String</span></code> with nullness operator
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> with nullness operator <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.” To reduce
that to a proper augmented type with a single nullness operator, we
define this process.</p>
</div></blockquote>
<p>To substitute each type argument <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code> for each corresponding type
parameter <code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>:</p>
<p>For every type-variable usage <code class="docutils literal notranslate"><span class="pre">V</span></code> whose <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is <code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>, replace <code class="docutils literal notranslate"><span class="pre">V</span></code> with the result of the following operation:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">V</span></code> is <a class="reference external" href="#trusted-null-exclusive-under-every-parameterization">trusted null-exclusive under every
parameterization</a>
in the <a class="reference external" href="#multiple-worlds">least convenient world</a>, then replace it
with the result of <a class="reference external" href="#applying-operator">applying</a> <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>
to <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code>.</p>
<blockquote>
<div><p>This is the one instance in which a rule references another rule
to be run under a <em>different</em> “world.” Normally, all rules are run
<a class="reference external" href="#propagating-multiple-worlds">under the same “world.”</a> But in
this instance, the null-exclusivity rule (and all rules that it in
turn applies) are always run in the least convenient world.</p>
</div></blockquote>
<blockquote>
<div><p>This special case improves behavior in “the
<code class="docutils literal notranslate"><span class="pre">ImmutableList.Builder</span></code> case”: Consider an unannotated user of
that class. Its builder will have an element type whose <a class="reference external" href="#nullness-operator">nullness
operator</a> is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>. Without this
special case, <code class="docutils literal notranslate"><span class="pre">builder.add(objectUnionNull)</span></code> would pass the
subtyping check in the <a class="reference external" href="#multiple-worlds">most convenient
world</a>. This would happen even though we have
enough information to know that the parameter to <code class="docutils literal notranslate"><span class="pre">add</span></code> is
universally null-exclusive — even in the most convenient world.
The special case here makes that subtyping check fail.</p>
</div></blockquote>
</li>
<li><p>Otherwise, replace <code class="docutils literal notranslate"><span class="pre">V</span></code> with the result of applying the nullness
operator of <code class="docutils literal notranslate"><span class="pre">V</span></code> to <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code>.</p></li>
</ul>
</div>
<div class="section" id="applying-a-nullness-operator-to-an-augmented-type">
<span id="applying-operator"></span><h2>Applying a nullness operator to an augmented type<a class="headerlink" href="#applying-a-nullness-operator-to-an-augmented-type" title="Permalink to this headline">¶</a></h2>
<p>The process of applying a <a class="reference external" href="#nullness-operator">nullness operator</a>
requires 2 inputs:</p>
<ul class="simple">
<li><p>the nullness operator to apply</p></li>
<li><p>the <a class="reference external" href="#augmented-type">augmented type</a> (which, again, includes a
<a class="reference external" href="#nullness-operator">nullness operator</a> for that type) to apply it
to</p></li>
</ul>
<p>The result of the process is an augmented type.</p>
<p>The process is as follows:</p>
<p>First, based on the pair of nullness operators (the one to apply and the
one from the augmented type), compute a “desired nullness operator.” Do
so by applying the following rules in order. Once one condition is met,
skip the remaining conditions.</p>
<ul class="simple">
<li><p>If the nullness operator to apply is <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, the desired
nullness operator is <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p></li>
<li><p>If either nullness operator is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>, the desired nullness
operator is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If either nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>, the desired nullness
operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p></li>
<li><p>The desired nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
</ul>
<p>Then, if the input augmented type is <em>not</em> an <a class="reference external" href="#intersection-types">intersection
type</a>, the output is the same as the input but
with its nullness operator replaced with the desired nullness operator.</p>
<p>Otherwise, the output is an intersection type. For every element <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code>
of the input type, the output type has an element that is the result of
applying the desired nullness operator to <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code>.</p>
<blockquote>
<div><p>In this case, the desired nullness operator is always equal to the
nullness operator to apply that was an input to this process. That’s
because the nullness operator of the intersection type itself is
defined to always be <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="capture-conversion">
<h2>Capture conversion<a class="headerlink" href="#capture-conversion" title="Permalink to this headline">¶</a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">JLS
5.1.10</a>.
We add to them as follows:</p>
<ul>
<li><p>The parameterized type that is the output of the conversion has the
same <a class="reference external" href="#nullness-operator">nullness operator</a> as the parameterized
type that is the input type.</p></li>
<li><p>Disregard the JLS rule about <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. Instead, treat <code class="docutils literal notranslate"><span class="pre">?</span></code> like
<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#nullness-operator">nullness
operator</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is specified
by <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>
like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>When a rule generates a lower bound that is the null type, we specify
that its nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>. (See <a class="reference external" href="#null-types">“Augmented null
types.”</a>)</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="index.html" class="btn btn-neutral float-left" title="JSpecify: Standard Java annotations for static analysis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, The JSpecify Authors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>