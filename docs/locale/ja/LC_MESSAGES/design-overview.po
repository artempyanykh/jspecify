# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018-2021, The JSpecify Authors
# This file is distributed under the same license as the JSpecify package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: JSpecify \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-14 10:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../design-overview.rst:2
msgid "JSpecify design overview"
msgstr "JSpecify設計概要"

#: ../../design-overview.rst:5
msgid "About this document"
msgstr "この文書について"

#: ../../design-overview.rst:7
msgid ""
"This document summarizes our current thinking for proposing a set of "
"nullness annotations. **Nothing here is “set in stone” yet.**"
msgstr "この文書は現時点における、私達のnullness用アノテーションの設計に対する提案をまとめています。**ここに書かれている内容は何も確定していません。**"

#: ../../design-overview.rst:10
msgid ""
"It will be very helpful to read or refer to the `core concepts/glossary "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit>`__ document in order to understand this "
"material correctly. There are numerous other documents in our `shared "
"folder "
"<https://drive.google.com/drive/folders/1vZl1odNCBncVaN7EwlwfqI05T_CHIqN->`__."
msgstr ""
"`コアコンセプトならびに用語集 <https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit>`__ "
"も合わせて確認すると、この資料を正しく理解する助けになります。その他のドキュメントも `共有フォルダ "
"<https://drive.google.com/drive/folders/1vZl1odNCBncVaN7EwlwfqI05T_CHIqN->`__"
" にて保存されています。"

#: ../../design-overview.rst:17
msgid "Overview"
msgstr "概要"

#: ../../design-overview.rst:19
msgid ""
"We propose a type annotation to specify the nullness of individual type "
"usages. At a high level, our proposed semantics is similar to existing "
"tools’ treatment of nullness type annotations. We treat nullness "
"annotations as purely compile-time type refinements without effect on "
"runtime semantics. Besides the typical “`nullable "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.ejpb5ee0msjt>`__” and “`non-"
"nullable <https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.8wgyiwyvi49f>`__” refinements, "
"we distinguish values of “`unspecified nullness "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.xb9w6p3ilsq3>`__”, which "
"typically arise from unannotated code, and allow for (with optional "
"warnings if desired) type checks involving “unspecified nullness” to "
"succeed even when they are unsound."
msgstr ""
"私達は、個々の“型の使用“（訳注：`type usage "
"<https://docs.oracle.com/javase/jp/8/docs/api/java/lang/annotation/ElementType.html#TYPE_USE>`__"
" "
"のこと）のnullnessを指定するための型注釈を提案します。高いレベルでは、我々の提案するセマンティクス（意味論）は、既存ツールが提供するnullness型アノテーションの扱いと似ています。我々はnullnessアノテーションを、実行時のセマンティクスに影響を与えない、純粋なコンパイル時の型の改良として扱います。この型注釈は典型的な“nullable“と"
"“non-nullable“の改良に加えて、注釈のないコードから一般的に生じる“unspecified "
"nullness“の値を区別し、“unspecified nullness“を含む型チェックが不健全であっても（訳注：`健全性 "
"<http://web.sfc.keio.ac.jp/~hagino/logic16/05.pdf>`__ "
"を満たさないという意味）成功させることができます（必要に応じてオプションで警告を表示します）。"

#: ../../design-overview.rst:33
msgid ""
"To avoid excessive annotation overhead in hand-written Java code while "
"clearly distinguishing annotated from legacy code, we also propose a "
"declaration annotation, with semantics similar to existing tools’ "
"semantics of “non-null by default.” In the absence of that annotation, "
"type usages will be considered of “unspecified nullness.”"
msgstr ""
"Javaコードに過剰なアノテーションを書いて回る手間を回避しつつ、アノテーションが施されたコードとそうでないレガシーなコードを明確に区別するために、既存のツールの"
" “non-null by default“に似たセマンティクスを持つ宣言アノテーションも提案します。このアノテーションがない場合、型の使用は "
"“unspecified nullness“ として扱われます。"

#: ../../design-overview.rst:39
msgid ""
"We give `semantics <#semantics>`__ to these annotations independent of "
"particular tools. We don’t specify what tools must do with that semantic "
"information, nor do we forbid them from adding to it (e.g., with flow "
"typing in implementation code). We merely define how to interpret our "
"annotations in method, field, and class declarations. This approach gives"
" documented meaning to annotations appearing in declarations while "
"allowing Java code authors to use their normal toolchain to compile code "
"(though we do recommend code authors use additional tools to minimize the"
" chance of incorrect annotations). Crucially, this approach also allows "
"any tool to interpret annotations that appear in Java bytecode produced "
"by other tools."
msgstr "これらのアノテーションには、特定のツールに依存しないセマンティクスが与えられています。ツールがその意味的な情報に対して何をしなければならないかは規定されていませんし、ツールが意味的な情報を追加することも禁止していません（例えば、実装コードでフロー型付けをするなど）。単純に、メソッド、フィールド、クラスの宣言でアノテーションをどのように解釈するかのみを定義しています。このアプローチは、宣言に現れるアノテーションに文書化された意味を与える一方で、Javaコードの作者が通常のツールチェーンを使ってコードをコンパイルすることを可能にします（ただし、間違ったアノテーションの可能性を最小限にするために、コード作者が追加のツールを使用することを推奨します）。重要なのは、とあるツールによって生成されたJavaバイトコードに現れるアノテーションを、他のどのツールでも解釈できるということです。"

#: ../../design-overview.rst:53
msgid ""
"We have adopted precise meanings for the terms used in this document; it "
"will be necessary to read (or refer to) the `glossary "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit>`__ document in order to interpret this "
"information correctly."
msgstr ""
"この文書で使用されている用語には正確な意味を採用するよう期していますが、これらの情報を正しく解釈するためには `用語集 "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit>`__ を読む、または参照する必要があります。"

#: ../../design-overview.rst:59
msgid "Semantics"
msgstr "セマンティクス"

#: ../../design-overview.rst:61
msgid "In this section, we discuss how type checking should play out."
msgstr "この節では、型検査がどのように行われるべきか説明します。"

#: ../../design-overview.rst:64
msgid "Type hierarchy"
msgstr "型の階層"

#: ../../design-overview.rst:66
msgid ""
"Our nullability annotations produce the following apparent type hierarchy"
" [`#80 <https://github.com/jspecify/jspecify/issues/80>`__]:"
msgstr ""
"私達のnullabilityアノテーションは、以下に挙げる明確な型の階層を生成します [`#80 "
"<https://github.com/jspecify/jspecify/issues/80>`__]:"

#: ../../design-overview.rst:69
msgid "``Foo`` (written in the scope of ``@NullMarked``)"
msgstr "``Foo`` (``@NullMarked`` のスコープで書かれたもの)"

#: ../../design-overview.rst:70
msgid "``⋖ Foo`` (written outside the scope of ``@NullMarked``)"
msgstr "``⋖ Foo`` (``@NullMarked`` のスコープ外で書かれたもの)"

#: ../../design-overview.rst:71
msgid "``⋖ @Nullable Foo``"
msgstr ""

#: ../../design-overview.rst:73
msgid ""
"It can be useful to conceptualize these similarly to `3-valued logic "
"<https://en.wikipedia.org/wiki/Three-valued_logic>`__ [`#33 "
"<https://github.com/jspecify/jspecify/issues/33>`__]. While that’s "
"workable, it can be useful to instead define “unspecified nullness” as an"
" existential quantification over the other two (which logically still "
"validates the above hierarchy). Two unrelated occurrences of unspecified "
"nullness can sometimes be represented as two different variables, similar"
" to how the Java type system handles wildcards."
msgstr ""
"これは `3値論理 <https://ja.wikipedia.org/wiki/3%E5%80%A4%E8%AB%96%E7%90%86>`__"
" [`#33 <https://github.com/jspecify/jspecify/issues/33>`__] "
"と同じような概念だと言えます。この方法も有効ですが、代わりに “unspecified nullness“ "
"を他の2つに対する存在量化として定義しても便利です（論理的には前述の階層を検証することになります）。Javaの型システムがワイルドカードを処理するのと同様に、2つの無関係な"
" “unspecified nullness“ が2つの異なる変数として表される場合があります。"

#: ../../design-overview.rst:82
msgid ""
"The above rules make ``@Nullable Object`` the top (least precise) type. "
"(Note that ``null`` is *not* the bottom type.) Here are some more "
"examples of subtyping, with types written in the scope of "
"``@NullMarked``:"
msgstr ""
"上記のルールにより、 ``@Nullable Object`` は最上位の（最も精度の低い）型となります。``null`` "
"は最下位の型ではないことに注意してください。以下に、 ``@NullMarked`` のスコープで書かれた型を使った細分化の例をいくつか示します。"

#: ../../design-overview.rst:87
msgid "``String ⋖ Object ⋖ @Nullable Object``"
msgstr ""

#: ../../design-overview.rst:88
msgid "``String ⋖ @Nullable String ⋖ @Nullable Object``"
msgstr ""

#: ../../design-overview.rst:89
msgid "``null ⋖ @Nullable String ⋖ @Nullable Object``"
msgstr ""

#: ../../design-overview.rst:91
msgid ""
"For a given set of types, we can define their **glb** (*greatest lower "
"bound*) as a type from the given set that is at least as specific as all "
"others. Similarly, the **lub** (*least upper bound*) of a set of types is"
" a type from the set that is at most as specific as all others."
msgstr ""
"任意の型の集合に対し、**下限** (*greatest lower bound, glb*) "
"をその集合に含まれる他のすべての型よりも小さなひとつの型として定義できます。同様に、**上限** (*least upper bound, "
"lub*)をその集合に含まれる他のすべての型よりも大きなひとつの型として定義できます"

#: ../../design-overview.rst:96
msgid ""
"Finally, a **type check** (e.g., to determine assignability) for a pair "
"of `augmented types <#augmented-type>`__ includes validating **both** (a)"
" a type check of the `base types "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i>`__, handled by "
"the off-the-shelf compiler, and (b) a type check for nullability."
msgstr ""
"最後に、`拡張型 <#augmented-type>`__ の組に対する **型チェック** （例えば割当可能性の判断）には(a) "
"一般的なコンパイラが扱う `基本型 <https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf"
"--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i>`__ と、(b) "
"nullabilityのための型チェック、その両方を検証することが含まれます。"

#: ../../design-overview.rst:103
msgid ""
"This specification additionally encourages allowing type checks involving"
" unspecified nullness to succeed even when they are **unsound** "
"(optionally with warnings, similar to “unchecked conversions” in Java "
"generics), such as the following [`#33 "
"<https://github.com/jspecify/jspecify/issues/33>`__]:"
msgstr ""

#: ../../design-overview.rst:109
msgid "a nullable type where a subtype of unspecified nullness is required"
msgstr ""

#: ../../design-overview.rst:111
msgid ""
"a type of unspecified nullness where a subtype of a non-null type is "
"required"
msgstr ""

#: ../../design-overview.rst:113
msgid ""
"a type of unspecified nullness where a subtype of unspecified nullness is"
" required"
msgstr ""

#: ../../design-overview.rst:116
msgid ""
"For usability reasons, many tools will not generate generate "
"warnings/errors when applying unsound rules like those above. Others may "
"generate them optionally, likely with the warnings/errors off by default."
" Even when a tool does report these warnings/errors, we **strongly** "
"encourage the tool to permit users to suppress these warnings without "
"suppressing other soundness violations."
msgstr ""

#: ../../design-overview.rst:123
msgid ""
"When converting type components of parameterized types, their "
"nullabilities should be considered invariant where their base types are."
msgstr ""

#: ../../design-overview.rst:127
msgid ""
"This means that “list of nullable string” and “list of non-null string” "
"are not convertible to each other, but “list of non-null string” is "
"convertible to ``List<? extends @Nullable String>``."
msgstr ""

#: ../../design-overview.rst:131
msgid ""
"In addition, we encourage unsoundly allowing unspecified nullness to be "
"“the same type” as any nullness, even for invariant type components [`#33"
" <https://github.com/jspecify/jspecify/issues/33>`__]. In particular, we "
"encourage allowing the following type checks to succeed unsoundly "
"(similar to raw type conversions) [`#69 "
"<https://github.com/jspecify/jspecify/issues/69>`__]:"
msgstr ""

#: ../../design-overview.rst:139
msgid ""
"“a list of ``Bar`` instances that are not null” is “the same type as” “a "
"list of ``Bar`` instances that have unspecified nullness”"
msgstr ""

#: ../../design-overview.rst:142
msgid ""
"“a list of ``Bar`` instances that are nullable” is “the same type as” “a "
"list of ``Bar`` instances that have unspecified nullness”"
msgstr ""

#: ../../design-overview.rst:147
msgid "Defaulting annotations in effect"
msgstr ""

#: ../../design-overview.rst:149
msgid ""
"For a given type usage, we define the **defaulting annotation in effect**"
" to be the one located at the *nearest containing scope* surrounding the "
"type usage."
msgstr ""

#: ../../design-overview.rst:153
msgid ""
"Class members are contained by classes, which may be contained by other "
"class members or classes, and top-level classes are contained by "
"packages, which may be contained by modules."
msgstr ""

#: ../../design-overview.rst:156
msgid ""
"If no such defaulting annotation exists, then no defaulting annotation is"
" in effect."
msgstr ""

#: ../../design-overview.rst:159
msgid ""
"We call any type usage that itself carries a `recognized <#recognized-"
"locations-for-type-use-annotations>`__ type-use annotation **explicitly "
"annotated**."
msgstr ""

#: ../../design-overview.rst:164
msgid "Parameterized types"
msgstr "パラメータ化された型"

#: ../../design-overview.rst:166
msgid ""
"This section directly builds on `JLS 4.5 "
"<https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5>`__"
" to extend nullability to parameterized types."
msgstr ""

#: ../../design-overview.rst:171
msgid "Parametric nullability"
msgstr ""

#: ../../design-overview.rst:173
msgid ""
"If a type parameter’s bound is nullable, then unannotated usages of that "
"type parameter (inside the scope of ``@NullMarked``) have *parametric "
"nullability*."
msgstr ""

#: ../../design-overview.rst:178
msgid "Type arguments of parameterized types"
msgstr ""

#: ../../design-overview.rst:180
msgid ""
"Tools may wish to check that type arguments are subtypes of the "
"corresponding bounds’ types (in addition to base type well-formedness, "
"see `JLS 4.5 "
"<https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5>`__)."
" As usual, tools may still wish to allow (with warning if desired) "
"unsound type arguments involving unspecified nullness."
msgstr ""

#: ../../design-overview.rst:187
msgid ""
"Specifically, a tool might reject a parameterized type with an explicit "
"annotation, such as ``ImmutableList<@Nullable String>``, if "
"``ImmutableList``\\ ’s type parameter is bounded to be non-null. The tool"
" might report an error when encountering this case in source code and "
"otherwise ignore the explicit ``@Nullable`` annotation."
msgstr ""

#: ../../design-overview.rst:194
msgid "Overriding"
msgstr "オーバーライド"

#: ../../design-overview.rst:196
msgid ""
"If a method overrides other methods according to Java language rules (see"
" `JLS 8.4.8.1 "
"<https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.8.1>`__,"
" also cf. `JVMS 5.4.5 "
"<https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-5.html#jvms-5.4.5>`__),"
" then tools may wish to check that:"
msgstr ""

#: ../../design-overview.rst:203
msgid ""
"The overriding method’s augmented return type is be return-type-"
"substitutable for the `supermethods "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.5nvbughni6vx>`__\\ ’ return "
"types (corresponds to covariant return types for base types, an "
"uncontroversial Java feature)."
msgstr ""

#: ../../design-overview.rst:209
msgid ""
"As usual, tools may wish to allow (with warning if desired) unsound "
"declarations involving unspecified nullness. Note that `supermethods "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.5nvbughni6vx>`__ and "
"`superparameters <https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf"
"--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.m2gxs1ddzqwp>`__ may be "
"defined by members of parameterized supertypes."
msgstr ""

#: ../../design-overview.rst:217
msgid "Concerns around uninitialized objects"
msgstr "未初期化オブジェクトに関する懸念点"

#: ../../design-overview.rst:219
msgid ""
"The broad intention of nullability is that type usages specified as non-"
"null should at runtime only represent non-null values. Since fields have "
"to be initialized before they can be non-null, this turns out to be "
"impractical in edge cases, however. Further, this problem can affect "
"method return values, e.g., when methods return field values. We "
"therefore likewise only expect non-null guarantees to hold for instance "
"(static, respectively) fields and method results by the time their "
"declaring class’s constructor (static initializer, respectively) has "
"finished (similar to when final fields are guaranteed to be initialized)."
msgstr ""

#: ../../design-overview.rst:230
msgid ""
"Note this semantics does allow for situations in which null values may be"
" observable in “non-null” fields and method returns, namely while objects"
" are under construction. We simply encourage API owners to minimize these"
" cases for non-private (both static and instance) fields and methods, "
"which typically involves not “leaking” object references outside an API "
"until they’re fully constructed. Some tools may attempt to identify such "
"“leaks” and may attempt to ensure proper field initialization as defined "
"here during object construction."
msgstr ""

#: ../../design-overview.rst:240
msgid "Examples"
msgstr ""

#: ../../design-overview.rst:242
msgid "As an example, let’s consider a fragment of Guava’s ``ImmutableMap``:"
msgstr ""

#: ../../design-overview.rst:252
msgid ""
"Because of the use of ``@NullMarked``, every type use in this class’s "
"declaration is fixed to either nullable or non-null (including type-"
"variable uses, since their type parameters are considered implicitly "
"bounded by non-null ``Object``)."
msgstr ""

#: ../../design-overview.rst:257
msgid ""
"Can the parameters to ``of()``\\ ’s be null? No, from ``K`` and ``V``\\ "
"’s bounds, which are determined implicitly by ``@NullMarked``."
msgstr ""

#: ../../design-overview.rst:259
msgid "Can ``get()``\\ ’s return ``null``? Yes, from its explicit annotation."
msgstr ""

#: ../../design-overview.rst:260
msgid ""
"It is a mismatch to refer to ``ImmutableMap<@Nullable String, Object>`` "
"because ``@Nullable String`` is outside of ``K``\\ ’s bounds."
msgstr ""

#: ../../design-overview.rst:264
msgid ""
"To illustrate wildcards, consider a method return type ``ImmutableMap<? "
"extends @Nullable String, ?>`` with no defaulting annotation in scope:"
msgstr ""

#: ../../design-overview.rst:268
msgid ""
"Can the method return a null map? That is unspecified, since no "
"defaulting annotation is in scope."
msgstr ""

#: ../../design-overview.rst:270
msgid ""
"Can the map’s keys or values be null? No, because the wildcards inherit "
"that bound from the bounds of ``K`` and ``V`` in ``ImmutableMap``."
msgstr ""

#: ../../design-overview.rst:274
msgid ""
"As another example, Guava’s ``Function`` would be declared as follows to "
"allow functions that accept and/or return ``null``:"
msgstr ""

#: ../../design-overview.rst:284
msgid ""
"Note ``F``\\ ’s and ``T``\\ ’s admittedly verbose but very explicit "
"``extends @Nullable Object`` bounds, which mean that ``apply``\\ ’s "
"parameter and result are of parametric nullability."
msgstr ""

#: ../../design-overview.rst:288
msgid ""
"Concrete ``Function`` implementations can still choose not to support "
"nulls:"
msgstr ""

#: ../../design-overview.rst:298
msgid "Discussion: Expression types"
msgstr ""

#: ../../design-overview.rst:300
msgid ""
"It is not the purpose of this proposal to dictate precise behavior that "
"checkers must follow. But we expect Java source code analyzers to want to"
" extend our semantics from type usages as defined above to expression "
"types (including expression type components)."
msgstr ""

#: ../../design-overview.rst:305
msgid ""
"As an example, consider a hypothetical annotated version of "
"``java.util.List``:"
msgstr ""

#: ../../design-overview.rst:316
msgid "Now, in client code like this:"
msgstr ""

#: ../../design-overview.rst:326
msgid ""
"Note that (because of the defaulting annotation in effect) both ``foo``\\"
" ’s return type’s and ``xs``\\ ’s ``String`` type argument’s are non-null"
" types. That means that, considering ``xs``\\ ’s type argument, "
"``xs.add()``\\ ’s expected parameter type is likewise non-null "
"``String``, as is ``xs.get()``\\ ’s return type."
msgstr ""

#: ../../design-overview.rst:332
msgid ""
"Note that unlike with base types, a ``null`` reference is *no longer* "
"automatically assignable to any type:"
msgstr ""

#: ../../design-overview.rst:335
msgid ""
"It clearly isn’t usable where a non-null value is required (as in the "
"example above)."
msgstr ""

#: ../../design-overview.rst:337
msgid ""
"It also isn’t assignable to types with parametric nullability (since "
"their type parameters permit non-null instantiations)."
msgstr ""

#: ../../design-overview.rst:340
msgid "For the latter point, consider the following example:"
msgstr ""

#: ../../design-overview.rst:357
msgid ""
"Again we do not prescribe how tools handle any of these scenarios, so "
"tools may be silent or issue lower-priority warnings on source lines "
"marked “mismatch” here. They’re purely illustrative of how we imagine "
"tools will apply semantics to expression typing."
msgstr ""
