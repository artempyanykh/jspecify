# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018-2021, The JSpecify Authors
# This file is distributed under the same license as the JSpecify package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: JSpecify \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-05 03:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../design-overview.rst:2
msgid "JSpecify design overview"
msgstr "JSpecify設計概要"

#: ../../design-overview.rst:5
msgid "About this document"
msgstr "この文書について"

#: ../../design-overview.rst:7
msgid ""
"This document summarizes our current thinking for proposing a set of "
"nullness annotations. **Nothing here is “set in stone” yet.**"
msgstr ""
"この文書は現時点における、私達のnullness用アノテーションの設計に対する提案をまとめています。"
"**ここに書かれている内容には確定したものはありません。**"

#: ../../design-overview.rst:10
msgid ""
"**As of March 2021, this doc is currently two docs concatenated together."
" They conflict with each other in places. We will iterate to address "
"this.**"
msgstr ""
"**2021年3月時点で、この文書は2つの文書を包括しています。またそれぞれの文書は互いに衝突してもいます。"
"この問題への対処は継続的に行っていきます。**"

#: ../../design-overview.rst:14
msgid ""
"It will be very helpful to read or refer to the `core concepts/glossary "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit>`__ document in order to understand this "
"material correctly. There are numerous other documents in our `shared "
"folder "
"<https://drive.google.com/drive/folders/1vZl1odNCBncVaN7EwlwfqI05T_CHIqN->`__."
msgstr ""

#: ../../design-overview.rst:21
msgid "Overview"
msgstr "概要"

#: ../../design-overview.rst:23
msgid ""
"We propose a type annotation to specify the nullness of individual type "
"usages. At a high level, our proposed semantics is similar to existing "
"tools’ treatment of nullness type annotations. We treat nullness "
"annotations as purely compile-time type refinements without effect on "
"runtime semantics. Besides the typical “`nullable "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.ejpb5ee0msjt>`__” and “`non-"
"nullable <https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.8wgyiwyvi49f>`__” refinements, "
"we distinguish values of “`unspecified nullness "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.xb9w6p3ilsq3>`__”, which "
"typically arise from unannotated code, and allow for (with optional "
"warnings if desired) type checks involving “unspecified nullness” to "
"succeed even when they are unsound."
msgstr ""

#: ../../design-overview.rst:37
msgid ""
"To avoid excessive annotation overhead in hand-written Java code while "
"clearly distinguishing annotated from legacy code, we also propose a "
"declaration annotation, with semantics similar to existing tools’ "
"semantics of “non-null by default.” In the absence of that annotation, "
"type usages will be considered of “unspecified nullness.”"
msgstr ""
"Javaコードに過剰なアノテーションを書いて回る手間を回避しつつ、アノテーションが施されたコードとそうでない"
"レガシーなコードを明確に区別するために、既存のツールの “non-null by default“に似たセマンティクスを持つ"
"宣言アノテーションも提案する。このアノテーションがない場合、型の使用は “unspecified nullness“ として扱われる。"

#: ../../design-overview.rst:43
msgid ""
"We give `semantics <#semantics>`__ to these annotations independent of "
"particular tools. We don’t specify what tools must do with that semantic "
"information, nor do we forbid them from adding to it (e.g., with flow "
"typing in implementation code). We merely define how to interpret our "
"annotations in method, field, and class declarations. This approach gives"
" documented meaning to annotations appearing in declarations while "
"allowing Java code authors to use their normal toolchain to compile code "
"(though we do recommend code authors use additional tools to minimize the"
" chance of incorrect annotations). Crucially, this approach also allows "
"any tool to interpret annotations that appear in Java bytecode produced "
"by other tools."
msgstr ""

#: ../../design-overview.rst:55
msgid ""
"**Note:** we have adopted precise meanings for the terms used in this "
"document; it will be necessary to read (or refer to) the `glossary "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit>`__ document in order to interpret this "
"information correctly."
msgstr ""

#: ../../design-overview.rst:61
msgid "Semantics"
msgstr "セマンティクス（意味論）"

#: ../../design-overview.rst:63
msgid "In this section, we discuss how type checking should play out."
msgstr "この節では、型検査がどのように行われるべきか説明します。"

#: ../../design-overview.rst:66
msgid "Type hierarchy"
msgstr "型の階層"

#: ../../design-overview.rst:68
msgid ""
"Our nullability annotations produce the following apparent type hierarchy"
" [`#80 <https://github.com/jspecify/jspecify/issues/80>`__]:"
msgstr ""
"私達のnullabilityアノテーションは、以下に挙げる明確な型の階層を生成します"
" [`#80 <https://github.com/jspecify/jspecify/issues/80>`__]:"

#: ../../design-overview.rst:71
msgid "``Foo`` (written in the scope of ``@NullMarked``)"
msgstr "``Foo`` (``@NullMarked`` のスコープで書かれたもの)"

#: ../../design-overview.rst:72
msgid "``⋖ Foo`` (written outside the scope of ``@NullMarked``)"
msgstr "``⋖ Foo`` (``@NullMarked`` のスコープ外で書かれたもの)"

#: ../../design-overview.rst:73
msgid "``⋖ @Nullable Foo``"
msgstr ""

#: ../../design-overview.rst:75
msgid ""
"It can be useful to conceptualize these similarly to `3-valued logic "
"<https://en.wikipedia.org/wiki/Three-valued_logic>`__ [`#33 "
"<https://github.com/jspecify/jspecify/issues/33>`__]. While that’s "
"workable, it can be useful to instead define “unspecified nullness” as an"
" existential quantification over the other two (which logically still "
"validates the above hierarchy). Two unrelated occurrences of unspecified "
"nullness can sometimes be represented as two different variables, similar"
" to how the Java type system handles wildcards."
msgstr ""
"これは `3値論理 <https://ja.wikipedia.org/wiki/3%E5%80%A4%E8%AB%96%E7%90%86>`__ [`#33 "
"<https://github.com/jspecify/jspecify/issues/33>`__] と同じような概念だと言えます。"
"この方法も有効ですが、代わりに “unspecified nullness“ を他の2つに対する存在量化として定義しても便利です"
"（論理的には前述の階層を検証することになります）。"
"Javaの型システムがワイルドカードを処理するのと同様に、2つの無関係な “unspecified nullness“ が"
"2つの異なる変数として表される場合があります。"

#: ../../design-overview.rst:84
msgid ""
"The above rules make ``@Nullable Object`` the top (least precise) type. "
"(Note that ``null`` is *not* the bottom type.) Here are some more "
"examples of subtyping, with types written in the scope of "
"``@NullMarked``:"
msgstr ""
"上記のルールにより、 ``@Nullable Object`` は最上位の（最も精度の低い）型となります。"
"``null`` は最下位の型ではないことに注意してください。"
"以下に、 ``@NullMarked`` のスコープで書かれた型を使った細分化の例をいくつか示します。"

#: ../../design-overview.rst:89
msgid "``String ⋖ Object ⋖ @Nullable Object``"
msgstr ""

#: ../../design-overview.rst:90
msgid "``String ⋖ @Nullable String ⋖ @Nullable Object``"
msgstr ""

#: ../../design-overview.rst:91
msgid "``null ⋖ @Nullable String ⋖ @Nullable Object``"
msgstr ""

#: ../../design-overview.rst:93
msgid ""
"For a given set of types, we can define their **glb** (*greatest lower "
"bound*) as a type from the given set that is at least as specific as all "
"others. Similarly, the **lub** (*least upper bound*) of a set of types is"
" a type from the set that is at most as specific as all others."
msgstr ""
"任意の型の集合に対し、**下限** (*greatest lower bound, glb*) をその集合に含まれる"
"他のすべての型よりも小さなひとつの型として定義できます。同様に、**上限** (*least upper bound, lub*)を"
"その集合に含まれる他のすべての型よりも大きなひとつの型として定義できます。

#: ../../design-overview.rst:98
msgid ""
"Finally, a **type check** (e.g., to determine assignability) for a pair "
"of `augmented types <#augmented-type>`__ includes validating **both** (a)"
" a type check of the `base types "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i>`__, handled by "
"the off-the-shelf compiler, and (b) a type check for nullability."
msgstr ""
"最後に、`拡張型 <#augmented-type>`__ の組に対する**型チェック**（例えば割当可能性の判断）には"
"(a) 一般的なコンパイラが扱う `基本型 <https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i>`__ と、"
"(b) nullabilityのための型チェック、その両方を検証することが含まれます。"

#: ../../design-overview.rst:105
msgid ""
"This specification additionally encourages allowing type checks involving"
" unspecified nullness to succeed even when they are **unsound** "
"(optionally with warnings, similar to “unchecked conversions” in Java "
"generics), such as the following [`#33 "
"<https://github.com/jspecify/jspecify/issues/33>`__]:"
msgstr ""

#: ../../design-overview.rst:111
msgid "a nullable type where a subtype of unspecified nullness is required"
msgstr ""

#: ../../design-overview.rst:113
msgid ""
"a type of unspecified nullness where a subtype of a non-null type is "
"required"
msgstr ""

#: ../../design-overview.rst:115
msgid ""
"a type of unspecified nullness where a subtype of unspecified nullness is"
" required"
msgstr ""

#: ../../design-overview.rst:118
msgid ""
"For usability reasons, many tools will not generate generate "
"warnings/errors when applying unsound rules like those above. Others may "
"generate them optionally, likely with the warnings/errors off by default."
" Even when a tool does report these warnings/errors, we **strongly** "
"encourage the tool to permit users to suppress these warnings without "
"suppressing other soundness violations."
msgstr ""

#: ../../design-overview.rst:125
msgid ""
"When converting type components of parameterized types, their "
"nullabilities should be considered invariant where their base types are."
msgstr ""

#: ../../design-overview.rst:129
msgid ""
"This means that “list of nullable string” and “list of non-null string” "
"are not convertible to each other, but “list of non-null string” is "
"convertible to ``List<? extends @Nullable String>``."
msgstr ""

#: ../../design-overview.rst:133
msgid ""
"In addition, we encourage unsoundly allowing unspecified nullness to be "
"“the same type” as any nullness, even for invariant type components [`#33"
" <https://github.com/jspecify/jspecify/issues/33>`__]. In particular, we "
"encourage allowing the following type checks to succeed unsoundly "
"(similar to raw type conversions) [`#69 "
"<https://github.com/jspecify/jspecify/issues/69>`__]:"
msgstr ""

#: ../../design-overview.rst:141
msgid ""
"“a list of ``Bar`` instances that are not null” is “the same type as” “a "
"list of ``Bar`` instances that have unspecified nullness”"
msgstr ""

#: ../../design-overview.rst:144
msgid ""
"“a list of ``Bar`` instances that are nullable” is “the same type as” “a "
"list of ``Bar`` instances that have unspecified nullness”"
msgstr ""

#: ../../design-overview.rst:149
msgid "Defaulting annotations in effect"
msgstr ""

#: ../../design-overview.rst:151
msgid ""
"For a given type usage, we define the **defaulting annotation in effect**"
" to be the one located at the *nearest containing scope* surrounding the "
"type usage."
msgstr ""

#: ../../design-overview.rst:155
msgid ""
"Class members are contained by classes, which may be contained by other "
"class members or classes, and top-level classes are contained by "
"packages, which may be contained by modules."
msgstr ""

#: ../../design-overview.rst:158
msgid ""
"If no such defaulting annotation exists, then no defaulting annotation is"
" in effect."
msgstr ""

#: ../../design-overview.rst:161
msgid ""
"We call any type usage that itself carries a `recognized <#recognized-"
"locations-for-type-use-annotations>`__ type-use annotation **explicitly "
"annotated**."
msgstr ""

#: ../../design-overview.rst:166
msgid "Parameterized types"
msgstr ""

#: ../../design-overview.rst:168
msgid ""
"This section directly builds on `JLS 4.5 "
"<https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5>`__"
" to extend nullability to parameterized types."
msgstr ""

#: ../../design-overview.rst:173
msgid "Parametric nullability"
msgstr ""

#: ../../design-overview.rst:175
msgid ""
"If a type parameter’s bound is nullable, then unannotated usages of that "
"type parameter (inside the scope of ``@NullMarked``) have *parametric "
"nullability*."
msgstr ""

#: ../../design-overview.rst:180
msgid "Type arguments of parameterized types"
msgstr ""

#: ../../design-overview.rst:182
msgid ""
"Tools may wish to check that type arguments are subtypes of the "
"corresponding bounds’ types (in addition to base type well-formedness, "
"see `JLS 4.5 "
"<https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5>`__)."
" As usual, tools may still wish to allow (with warning if desired) "
"unsound type arguments involving unspecified nullness."
msgstr ""

#: ../../design-overview.rst:189
msgid ""
"Specifically, a tool might reject a parameterized type with an explicit "
"annotation, such as ``ImmutableList<@Nullable String>``, if "
"``ImmutableList``\\ ’s type parameter is bounded to be non-null. The tool"
" might report an error when encountering this case in source code and "
"otherwise ignore the explicit ``@Nullable`` annotation."
msgstr ""

#: ../../design-overview.rst:196
msgid "Overriding"
msgstr "オーバーライド"

#: ../../design-overview.rst:198
msgid ""
"If a method overrides other methods according to Java language rules (see"
" `JLS 8.4.8.1 "
"<https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.8.1>`__,"
" also cf. `JVMS 5.4.5 "
"<https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-5.html#jvms-5.4.5>`__),"
" then tools may wish to check that:"
msgstr ""

#: ../../design-overview.rst:205
msgid ""
"The overriding method’s augmented return type is be return-type-"
"substitutable for the `supermethods "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.5nvbughni6vx>`__\\ ’ return "
"types (corresponds to covariant return types for base types, an "
"uncontroversial Java feature)."
msgstr ""

#: ../../design-overview.rst:211
msgid ""
"As usual, tools may wish to allow (with warning if desired) unsound "
"declarations involving unspecified nullness. Note that `supermethods "
"<https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--"
"w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.5nvbughni6vx>`__ and "
"`superparameters <https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf"
"--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.m2gxs1ddzqwp>`__ may be "
"defined by members of parameterized supertypes."
msgstr ""

#: ../../design-overview.rst:219
msgid "Concerns around uninitialized objects"
msgstr "未初期化オブジェクトに関する懸念点"

#: ../../design-overview.rst:221
msgid ""
"The broad intention of nullability is that type usages specified as non-"
"null should at runtime only represent non-null values. Since fields have "
"to be initialized before they can be non-null, this turns out to be "
"impractical in edge cases, however. Further, this problem can affect "
"method return values, e.g., when methods return field values. We "
"therefore likewise only expect non-null guarantees to hold for instance "
"(static, respectively) fields and method results by the time their "
"declaring class’s constructor (static initializer, respectively) has "
"finished (similar to when final fields are guaranteed to be initialized)."
msgstr ""

#: ../../design-overview.rst:232
msgid ""
"Note this semantics does allow for situations in which null values may be"
" observable in “non-null” fields and method returns, namely while objects"
" are under construction. We simply encourage API owners to minimize these"
" cases for non-private (both static and instance) fields and methods, "
"which typically involves not “leaking” object references outside an API "
"until they’re fully constructed. Some tools may attempt to identify such "
"“leaks” and may attempt to ensure proper field initialization as defined "
"here during object construction."
msgstr ""

#: ../../design-overview.rst:242
msgid "Examples"
msgstr ""

#: ../../design-overview.rst:244
msgid "As an example, let’s consider a fragment of Guava’s ``ImmutableMap``:"
msgstr ""

#: ../../design-overview.rst:254
msgid ""
"Because of the use of ``@NullMarked``, every type use in this class’s "
"declaration is fixed to either nullable or non-null (including type-"
"variable uses, since their type parameters are considered implicitly "
"bounded by non-null ``Object``)."
msgstr ""

#: ../../design-overview.rst:259
msgid ""
"Can the parameters to ``of()``\\ ’s be null? No, from ``K`` and ``V``\\ "
"’s bounds, which are determined implicitly by ``@NullMarked``."
msgstr ""

#: ../../design-overview.rst:261
msgid "Can ``get()``\\ ’s return ``null``? Yes, from its explicit annotation."
msgstr ""

#: ../../design-overview.rst:262
msgid ""
"It is a mismatch to refer to ``ImmutableMap<@Nullable String, Object>`` "
"because ``@Nullable String`` is outside of ``K``\\ ’s bounds."
msgstr ""

#: ../../design-overview.rst:266
msgid ""
"To illustrate wildcards, consider a method return type ``ImmutableMap<? "
"extends @Nullable String, ?>`` with no defaulting annotation in scope:"
msgstr ""

#: ../../design-overview.rst:270
msgid ""
"Can the method return a null map? That is unspecified, since no "
"defaulting annotation is in scope."
msgstr ""

#: ../../design-overview.rst:272
msgid ""
"Can the map’s keys or values be null? No, because the wildcards inherit "
"that bound from the bounds of ``K`` and ``V`` in ``ImmutableMap``."
msgstr ""

#: ../../design-overview.rst:276
msgid ""
"As another example, Guava’s ``Function`` would be declared as follows to "
"allow functions that accept and/or return ``null``:"
msgstr ""

#: ../../design-overview.rst:286
msgid ""
"Note ``F``\\ ’s and ``T``\\ ’s admittedly verbose but very explicit "
"``extends @Nullable Object`` bounds, which mean that ``apply``\\ ’s "
"parameter and result are of parametric nullability."
msgstr ""

#: ../../design-overview.rst:290
msgid ""
"Concrete ``Function`` implementations can still choose not to support "
"nulls:"
msgstr ""

#: ../../design-overview.rst:300
msgid "Discussion: Expression types"
msgstr ""

#: ../../design-overview.rst:302
msgid ""
"It is not the purpose of this proposal to dictate precise behavior that "
"checkers must follow. But we expect Java source code analyzers to want to"
" extend our semantics from type usages as defined above to expression "
"types (including expression type components)."
msgstr ""

#: ../../design-overview.rst:307
msgid ""
"As an example, consider a hypothetical annotated version of "
"``java.util.List``:"
msgstr ""

#: ../../design-overview.rst:318
msgid "Now, in client code like this:"
msgstr ""

#: ../../design-overview.rst:328
msgid ""
"Note that (because of the defaulting annotation in effect) both ``foo``\\"
" ’s return type’s and ``xs``\\ ’s ``String`` type argument’s are non-null"
" types. That means that, considering ``xs``\\ ’s type argument, "
"``xs.add()``\\ ’s expected parameter type is likewise non-null "
"``String``, as is ``xs.get()``\\ ’s return type."
msgstr ""

#: ../../design-overview.rst:334
msgid ""
"Note that unlike with base types, a ``null`` reference is *no longer* "
"automatically assignable to any type:"
msgstr ""

#: ../../design-overview.rst:337
msgid ""
"It clearly isn’t usable where a non-null value is required (as in the "
"example above)."
msgstr ""

#: ../../design-overview.rst:339
msgid ""
"It also isn’t assignable to types with parametric nullability (since "
"their type parameters permit non-null instantiations)."
msgstr ""

#: ../../design-overview.rst:342
msgid "For the latter point, consider the following example:"
msgstr ""

#: ../../design-overview.rst:359
msgid ""
"Again we do not prescribe how tools handle any of these scenarios, so "
"tools may be silent or issue lower-priority warnings on source lines "
"marked “mismatch” here. They’re purely illustrative of how we imagine "
"tools will apply semantics to expression typing."
msgstr ""

