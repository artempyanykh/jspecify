

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>JSpecify spec outline &mdash; JSpecify  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="prev" title="JSpecify: 静的解析のための標準化されたJavaアノテーション" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> JSpecify
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">コンテンツ</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">JSpecify spec outline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general">General</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-type-use-annotation">The type-use annotation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recognized-locations-for-type-use-annotations">Recognized locations for type-use annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-declaration-annotation">The declaration annotation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recognized-locations-for-declaration-annotations">Recognized locations for declaration annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#semantics">Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#type-hierarchy">Type hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defaulting-annotations-in-effect">Defaulting annotations in effect</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameterized-types">Parameterized types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parametric-nullability">Parametric nullability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-arguments-of-parameterized-types">Type arguments of parameterized types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#overriding">Overriding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concerns-around-uninitialized-objects">Concerns around uninitialized objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#discussion-expression-types">Discussion: Expression types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-simplest-thing-that-could-possibly-work-for-subtyping">The Simplest(?) Thing That Could Possibly Work for subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references-to-concepts-defined-by-this-spec">References to concepts defined by this spec</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-operator">Nullness operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type">Augmented type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#null-marked-scope">Null-marked scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-a-type-usage-appearing-in-code">Augmented type of a type usage appearing in code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-an-intersection-type">Augmented type of an intersection type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-unbounded-wildcard">Bound of an “unbounded” wildcard</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-object-bounded-type-parameter">Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-null-types">Augmented null types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-least-convenient-world-and-the-most-convenient-world">The least convenient world and the most convenient world</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#propagating-the-most-least-convenient-world">Propagating the most/least convenient world</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#same-type">Same type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subtyping">Subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-delegating-subtyping-rules-for-java">Nullness-delegating subtyping rules for Java</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtyping">Nullness subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trusted-null-inclusive-under-every-parameterization">Trusted null-inclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trusted-null-exclusive-under-every-parameterization">Trusted null-exclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-path">Nullness-subtype-establishing path</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-direct-supertype-edges">Nullness-subtype-establishing direct-supertype edges</a></li>
<li class="toctree-l2"><a class="reference internal" href="#containment">Containment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#substitution">Substitution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#applying-a-nullness-operator-to-an-augmented-type">Applying a nullness operator to an augmented type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capture-conversion">Capture conversion</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">JSpecify</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>JSpecify spec outline</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/spec.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="jspecify-spec-outline">
<h1>JSpecify spec outline<a class="headerlink" href="#jspecify-spec-outline" title="このヘッドラインへのパーマリンク">¶</a></h1>
<blockquote>
<div><p class="rubric" id="about-this-document">About this document</p>
<p>This document summarizes our current thinking for proposing a set of
nullness annotations. <strong>Nothing here is “set in stone” yet.</strong></p>
<p><strong>As of March 2021, this doc is currently two docs concatenated
together. They conflict with each other in places. We will iterate to
address this.</strong></p>
<p>It will be very helpful to read or refer to the <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit">core
concepts/glossary</a>
document in order to understand this material correctly. There are
numerous other documents in our <a class="reference external" href="https://drive.google.com/drive/folders/1vZl1odNCBncVaN7EwlwfqI05T_CHIqN-">shared
folder</a>.</p>
<p class="rubric" id="overview">Overview</p>
<p>We propose a type annotation to specify the nullness of individual
type usages. At a high level, our proposed semantics is similar to
existing tools’ treatment of nullness type annotations. We treat
nullness annotations as purely compile-time type refinements without
effect on runtime semantics. Besides the typical
“<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.ejpb5ee0msjt">nullable</a>”
and
“<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.8wgyiwyvi49f">non-nullable</a>”
refinements, we distinguish values of “<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.xb9w6p3ilsq3">unspecified
nullness</a>”,
which typically arise from unannotated code, and allow for (with
optional warnings if desired) type checks involving “unspecified
nullness” to succeed even when they are unsound.</p>
<p>To avoid excessive annotation overhead in hand-written Java code
while clearly distinguishing annotated from legacy code, we also
propose a declaration annotation, with semantics similar to existing
tools’ semantics of “non-null by default.” In the absence of that
annotation, type usages will be considered of “unspecified nullness.”</p>
<p>We give <a class="reference external" href="#semantics">semantics</a> to these annotations independent
of particular tools. We don’t specify what tools must do with that
semantic information, nor do we forbid them from adding to it (e.g.,
with flow typing in implementation code). We merely define how to
interpret our annotations in method, field, and class declarations.
This approach gives documented meaning to annotations appearing in
declarations while allowing Java code authors to use their normal
toolchain to compile code (though we do recommend code authors use
additional tools to minimize the chance of incorrect annotations).
Crucially, this approach also allows any tool to interpret
annotations that appear in Java bytecode produced by other tools.</p>
<p><strong>Note:</strong> we have adopted precise meanings for the terms used in this
document; it will be necessary to read (or refer to) the
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit">glossary</a>
document in order to interpret this information correctly.</p>
</div></blockquote>
<div class="section" id="general">
<h2>General<a class="headerlink" href="#general" title="このヘッドラインへのパーマリンク">¶</a></h2>
<ul class="simple">
<li><p>The package name is <code class="docutils literal notranslate"><span class="pre">org.jspecify.nullness</span></code>.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/1">#1</a>]</p></li>
<li><p>The JPMS module name is <code class="docutils literal notranslate"><span class="pre">org.jspecify</span></code>.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/181">#181</a>]</p></li>
<li><p>The Maven artifact is <code class="docutils literal notranslate"><span class="pre">org.jspecify:jspecify</span></code>.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/181">#181</a>]</p></li>
</ul>
<p>All annotations have runtime retention.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/28">#28</a>] None of the
annotations are marked
<a class="reference external" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/annotation/Repeatable.html">repeatable</a>.</p>
</div>
<div class="section" id="the-type-use-annotation">
<h2>The type-use annotation<a class="headerlink" href="#the-type-use-annotation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We provide a parameterless type-use annotation called <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>.</p>
<div class="section" id="recognized-locations-for-type-use-annotations">
<h3>Recognized locations for type-use annotations<a class="headerlink" href="#recognized-locations-for-type-use-annotations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Our type-use annotation is specified to be <em>recognized</em> in the
circumstances detailed below. An annotation in a recognized location has
the semantics described in this spec. The spec does not assign meaning
to annotations in unrecognized locations.</p>
<blockquote>
<div><p>Of course, when an annotation appears in an recognized location, that
does not make it “correct”: It may specify a type that a tool can
identify as <em>incompatible</em> with the type that the tool requires for
that particular location, given the information it has about related
code from annotations and other sources.</p>
</div></blockquote>
<ul>
<li><p>Unrecognized when applied to any component of a type usage in
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.cjuxrgo7keqs">implementation
code</a>:</p>
<ul class="simple">
<li><p>A local variable type.</p></li>
<li><p>The type in a cast expression.</p></li>
<li><p>An array or object creation expression.</p></li>
<li><p>An explicit type argument supplied to a generic method or
constructor (including via a member reference), or to an instance
creation expression for a generic class.</p></li>
</ul>
</li>
<li><p>Unrecognized when applied to a class declaration.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/7">#7</a>]</p>
<blockquote>
<div><p>For example, <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">&#64;Nullable</span> <span class="pre">class</span> <span class="pre">Foo</span> <span class="pre">{}</span></code> is unrecognized.</p>
</div></blockquote>
</li>
<li><p>Unrecognized on type usages that are intrinsically non-nullable:
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/17">#17</a>]</p>
<ul>
<li><p>When the annotated type usage is of any primitive type.</p></li>
<li><p>For the outer type that qualifies an inner type.</p>
<blockquote>
<div><p>For example, <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span> <span class="pre">Foo.Bar</span></code> is unrecognized because the
outer type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> is intrinsically non-nullable.</p>
</div></blockquote>
</li>
<li><p>In any of the following non-nullable type contexts:</p>
<ul class="simple">
<li><p>supertype in a class declaration</p></li>
<li><p>thrown exception type</p></li>
<li><p>enum constant declaration</p></li>
<li><p>receiver parameter type</p></li>
</ul>
</li>
</ul>
<p>But note that the following rules still apply to any non-root
component types of such type usages.</p>
</li>
<li><p>Unrecognized on any component of a receiver parameter type.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/157">#157</a>]</p>
<blockquote>
<div><p>This partially overlaps with the rule about non-nullable type
contexts above: Both rules cover an annotation on the
intrinsically non-nullable top-level type, but this rule extends
that to <em>all</em> components of the type.</p>
</div></blockquote>
</li>
<li><p>Otherwise, recognized on any
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.j1ewrpknx869">non-root</a>
component type, regardless of the root type or surrounding <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.pfoww2aic35t">type
context</a>.</p>
<ul>
<li><p>This may be a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.3gm7aajjj46m">type
argument</a>,
explicit wildcard bound, array component type, or the type used in
a variadic parameter declaration.</p>
<blockquote>
<div><p>For example, the annotation in <code class="docutils literal notranslate"><span class="pre">Iterator&lt;&#64;Nullable</span> <span class="pre">String&gt;</span></code>
is always recognized.</p>
</div></blockquote>
</li>
<li><p>Exception: Annotations on a type parameter or wildcard <em>itself</em>
are unrecognized.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/19">#19</a>,
<a class="reference external" href="https://github.com/jspecify/jspecify/issues/31">#31</a>]</p>
<blockquote>
<div><p>Annotations on their <em>bounds</em> are still recognized.</p>
</div></blockquote>
</li>
</ul>
</li>
<li><p>Recognized in the following type contexts (including when the type
usage is a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.uxek2gfsybvo">type
variable</a>,
regardless of the corresponding type parameter’s bound):
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/17">#17</a>]</p>
<ul>
<li><p>Return type of a method.</p></li>
<li><p>Formal parameter type of a method or constructor.</p></li>
<li><p>Field type.</p></li>
<li><p>Type parameter upper bound.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/60">#60</a>]</p>
<blockquote>
<div><p>But, again, <em>not</em> the type parameter itself.</p>
</div></blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<div><p>Tools are encouraged to treat an unrecognized annotation in Java
source code as an error unless they define semantics for that
location – and especially to treat annotations on intrinsically
non-nullable locations as an error. In bytecode, unrecognized
annotations may be best ignored (again, unless a tool defines
semantics for them).</p>
</div></blockquote>
</div>
</div>
<div class="section" id="the-declaration-annotation">
<h2>The declaration annotation<a class="headerlink" href="#the-declaration-annotation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We provide a single parameterless declaration annotation called
<code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/5">#5</a>,
<a class="reference external" href="https://github.com/jspecify/jspecify/issues/87">#87</a>]</p>
<div class="section" id="recognized-locations-for-declaration-annotations">
<h3>Recognized locations for declaration annotations<a class="headerlink" href="#recognized-locations-for-declaration-annotations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Our declaration annotation is specified to be <em>recognized</em> when applied
to the locations listed below:</p>
<ul class="simple">
<li><p>A <em>named</em> class.</p></li>
<li><p>A package. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/34">#34</a>]</p></li>
<li><p>A module. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/34">#34</a>]</p></li>
</ul>
<blockquote>
<div><p><em>Not</em> a method
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/43">#43</a>],
constructor
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/43">#43</a>], or field
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/50">#50</a>].</p>
</div></blockquote>
</div>
</div>
<div class="section" id="semantics">
<h2>Semantics<a class="headerlink" href="#semantics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In this section, we discuss how type checking should play out.</p>
<div class="section" id="type-hierarchy">
<h3>Type hierarchy<a class="headerlink" href="#type-hierarchy" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Our nullability annotations produce the following apparent type
hierarchy [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/80">#80</a>]:</p>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Foo</span></code> (written in the scope of <code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>)</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">⋖</span> <span class="pre">Foo</span></code> (written outside the scope of <code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>)</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">⋖</span> <span class="pre">&#64;Nullable</span> <span class="pre">Foo</span></code></div>
</div>
<p>It can be useful to conceptualize these similarly to <a class="reference external" href="https://en.wikipedia.org/wiki/Three-valued_logic">3-valued
logic</a>
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/33">#33</a>]. While that’s
workable, it can be useful to instead define “unspecified nullness” as
an existential quantification over the other two (which logically still
validates the above hierarchy). Two unrelated occurrences of unspecified
nullness can sometimes be represented as two different variables,
similar to how the Java type system handles wildcards.</p>
<p>The above rules make <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span> <span class="pre">Object</span></code> the top (least precise) type.
(Note that <code class="docutils literal notranslate"><span class="pre">null</span></code> is <em>not</em> the bottom type.) Here are some more
examples of subtyping, with types written in the scope of
<code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">⋖</span> <span class="pre">Object</span> <span class="pre">⋖</span> <span class="pre">&#64;Nullable</span> <span class="pre">Object</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">⋖</span> <span class="pre">&#64;Nullable</span> <span class="pre">String</span> <span class="pre">⋖</span> <span class="pre">&#64;Nullable</span> <span class="pre">Object</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">null</span> <span class="pre">⋖</span> <span class="pre">&#64;Nullable</span> <span class="pre">String</span> <span class="pre">⋖</span> <span class="pre">&#64;Nullable</span> <span class="pre">Object</span></code></p></li>
</ul>
<p>For a given set of types, we can define their <strong>glb</strong> (<em>greatest lower
bound</em>) as a type from the given set that is at least as specific as all
others. Similarly, the <strong>lub</strong> (<em>least upper bound</em>) of a set of types
is a type from the set that is at most as specific as all others.</p>
<p>Finally, a <strong>type check</strong> (e.g., to determine assignability) for a pair
of <a class="reference external" href="#augmented-type">augmented types</a> includes validating <strong>both</strong>
(a) a type check of the <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
types</a>,
handled by the off-the-shelf compiler, and (b) a type check for
nullability.</p>
<ul class="simple">
<li><p>This specification additionally encourages allowing type checks
involving unspecified nullness to succeed even when they are
<strong>unsound</strong> (optionally with warnings, similar to “unchecked
conversions” in Java generics), such as the following
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/33">#33</a>]:</p>
<ul>
<li><p>a nullable type where a subtype of unspecified nullness is
required</p></li>
<li><p>a type of unspecified nullness where a subtype of a non-null type
is required</p></li>
<li><p>a type of unspecified nullness where a subtype of unspecified
nullness is required</p></li>
</ul>
</li>
<li><p>For usability reasons, many tools will not generate generate
warnings/errors when applying unsound rules like those above. Others
may generate them optionally, likely with the warnings/errors off by
default. Even when a tool does report these warnings/errors, we
<strong>strongly</strong> encourage the tool to permit users to suppress these
warnings without suppressing other soundness violations.</p></li>
<li><p>When converting type components of parameterized types, their
nullabilities should be considered invariant where their base types
are.</p>
<ul>
<li><p>This means that “list of nullable string” and “list of non-null
string” are not convertible to each other, but “list of non-null
string” is convertible to <code class="docutils literal notranslate"><span class="pre">List&lt;?</span> <span class="pre">extends</span> <span class="pre">&#64;Nullable</span> <span class="pre">String&gt;</span></code>.</p></li>
<li><p>In addition, we encourage unsoundly allowing unspecified nullness
to be “the same type” as any nullness, even for invariant type
components
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/33">#33</a>]. In
particular, we encourage allowing the following type checks to
succeed unsoundly (similar to raw type conversions)
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/69">#69</a>]:</p>
<ul>
<li><p>“a list of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> instances that are not null” is “the same
type as” “a list of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> instances that have unspecified
nullness”</p></li>
<li><p>“a list of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> instances that are nullable” is “the same
type as” “a list of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> instances that have unspecified
nullness”</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="defaulting-annotations-in-effect">
<h3>Defaulting annotations in effect<a class="headerlink" href="#defaulting-annotations-in-effect" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>For a given type usage, we define the <strong>defaulting annotation in
effect</strong> to be the one located at the <em>nearest containing scope</em>
surrounding the type usage.</p>
<ul class="simple">
<li><p>Class members are contained by classes, which may be contained by
other class members or classes, and top-level classes are contained
by packages, which may be contained by modules.</p></li>
<li><p>If no such defaulting annotation exists, then no defaulting
annotation is in effect.</p></li>
</ul>
<p>We call any type usage that itself carries a
<a class="reference external" href="#recognized-locations-for-type-use-annotations">recognized</a> type-use
annotation <strong>explicitly annotated</strong>.</p>
</div>
<div class="section" id="parameterized-types">
<h3>Parameterized types<a class="headerlink" href="#parameterized-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>This section directly builds on <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5">JLS
4.5</a>
to extend nullability to parameterized types.</p>
<div class="section" id="parametric-nullability">
<h4>Parametric nullability<a class="headerlink" href="#parametric-nullability" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>If a type parameter’s bound is nullable, then unannotated usages of that
type parameter (inside the scope of <code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>) have <em>parametric
nullability</em>.</p>
</div>
<div class="section" id="type-arguments-of-parameterized-types">
<h4>Type arguments of parameterized types<a class="headerlink" href="#type-arguments-of-parameterized-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Tools may wish to check that type arguments are subtypes of the
corresponding bounds’ types (in addition to base type well-formedness,
see <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5">JLS
4.5</a>).
As usual, tools may still wish to allow (with warning if desired)
unsound type arguments involving unspecified nullness.</p>
<p>Specifically, a tool might reject a parameterized type with an explicit
annotation, such as <code class="docutils literal notranslate"><span class="pre">ImmutableList&lt;&#64;Nullable</span> <span class="pre">String&gt;</span></code>, if
<code class="docutils literal notranslate"><span class="pre">ImmutableList</span></code>’s type parameter is bounded to be non-null. The tool
might report an error when encountering this case in source code and
otherwise ignore the explicit <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code> annotation.</p>
</div>
</div>
<div class="section" id="overriding">
<h3>Overriding<a class="headerlink" href="#overriding" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If a method overrides other methods according to Java language rules
(see <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.8.1">JLS
8.4.8.1</a>,
also cf. <a class="reference external" href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-5.html#jvms-5.4.5">JVMS
5.4.5</a>),
then tools may wish to check that:</p>
<ul class="simple">
<li><p>The overriding method’s augmented return type is be
return-type-substitutable for the
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.5nvbughni6vx">supermethods</a>’
return types (corresponds to covariant return types for base types,
an uncontroversial Java feature).</p></li>
</ul>
<p>As usual, tools may wish to allow (with warning if desired) unsound
declarations involving unspecified nullness. Note that
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.5nvbughni6vx">supermethods</a>
and
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.m2gxs1ddzqwp">superparameters</a>
may be defined by members of parameterized supertypes.</p>
</div>
<div class="section" id="concerns-around-uninitialized-objects">
<h3>Concerns around uninitialized objects<a class="headerlink" href="#concerns-around-uninitialized-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The broad intention of nullability is that type usages specified as
non-null should at runtime only represent non-null values. Since fields
have to be initialized before they can be non-null, this turns out to be
impractical in edge cases, however. Further, this problem can affect
method return values, e.g., when methods return field values. We
therefore likewise only expect non-null guarantees to hold for instance
(static, respectively) fields and method results by the time their
declaring class’s constructor (static initializer, respectively) has
finished (similar to when final fields are guaranteed to be
initialized).</p>
<p>Note this semantics does allow for situations in which null values may
be observable in “non-null” fields and method returns, namely while
objects are under construction. We simply encourage API owners to
minimize these cases for non-private (both static and instance) fields
and methods, which typically involves not “leaking” object references
outside an API until they’re fully constructed. Some tools may attempt
to identify such “leaks” and may attempt to ensure proper field
initialization as defined here during object construction.</p>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>As an example, let’s consider a fragment of Guava’s <code class="docutils literal notranslate"><span class="pre">ImmutableMap</span></code>:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="nd">@NullMarked</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ImmutableMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">of</span><span class="p">(</span><span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">value</span><span class="p">);</span>
  <span class="kd">public</span> <span class="nd">@Nullable</span> <span class="n">V</span> <span class="nf">get</span><span class="p">(</span><span class="nd">@Nullable</span> <span class="n">Object</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because of the use of <code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>, every type use in this class’s
declaration is fixed to either nullable or non-null (including
type-variable uses, since their type parameters are considered
implicitly bounded by non-null <code class="docutils literal notranslate"><span class="pre">Object</span></code>).</p>
<ul class="simple">
<li><p>Can the parameters to <code class="docutils literal notranslate"><span class="pre">of()</span></code>’s be null? No, from <code class="docutils literal notranslate"><span class="pre">K</span></code> and
<code class="docutils literal notranslate"><span class="pre">V</span></code>’s bounds, which are determined implicitly by <code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>.</p></li>
<li><p>Can <code class="docutils literal notranslate"><span class="pre">get()</span></code>’s return <code class="docutils literal notranslate"><span class="pre">null</span></code>? Yes, from its explicit annotation.</p></li>
<li><p>It is a mismatch to refer to
<code class="docutils literal notranslate"><span class="pre">ImmutableMap&lt;&#64;Nullable</span> <span class="pre">String,</span> <span class="pre">Object&gt;</span></code> because
<code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span> <span class="pre">String</span></code> is outside of <code class="docutils literal notranslate"><span class="pre">K</span></code>’s bounds.</p></li>
</ul>
<p>To illustrate wildcards, consider a method return type
<code class="docutils literal notranslate"><span class="pre">ImmutableMap&lt;?</span> <span class="pre">extends</span> <span class="pre">&#64;Nullable</span> <span class="pre">String,</span> <span class="pre">?&gt;</span></code> with no defaulting
annotation in scope:</p>
<ul class="simple">
<li><p>Can the method return a null map? That is unspecified, since no
defaulting annotation is in scope.</p></li>
<li><p>Can the map’s keys or values be null? No, because the wildcards
inherit that bound from the bounds of <code class="docutils literal notranslate"><span class="pre">K</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code> in
<code class="docutils literal notranslate"><span class="pre">ImmutableMap</span></code>.</p></li>
</ul>
<p>As another example, Guava’s <code class="docutils literal notranslate"><span class="pre">Function</span></code> would be declared as follows to
allow functions that accept and/or return <code class="docutils literal notranslate"><span class="pre">null</span></code>:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="nd">@NullMarked</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="n">F</span> <span class="kd">extends</span> <span class="nd">@Nullable</span> <span class="n">Object</span><span class="p">,</span> <span class="n">T</span> <span class="kd">extends</span> <span class="nd">@Nullable</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">T</span> <span class="nf">apply</span><span class="p">(</span><span class="n">F</span> <span class="n">in</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">F</span></code>’s and <code class="docutils literal notranslate"><span class="pre">T</span></code>’s admittedly verbose but very explicit
<code class="docutils literal notranslate"><span class="pre">extends</span> <span class="pre">&#64;Nullable</span> <span class="pre">Object</span></code> bounds, which mean that <code class="docutils literal notranslate"><span class="pre">apply</span></code>’s
parameter and result are of parametric nullability.</p>
<p>Concrete <code class="docutils literal notranslate"><span class="pre">Function</span></code> implementations can still choose not to support
nulls:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="nd">@NullMarked</span>
<span class="kd">class</span> <span class="nc">Foo</span> <span class="kd">implements</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="discussion-expression-types">
<h2>Discussion: Expression types<a class="headerlink" href="#discussion-expression-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>It is not the purpose of this proposal to dictate precise behavior that
checkers must follow. But we expect Java source code analyzers to want
to extend our semantics from type usages as defined above to expression
types (including expression type components).</p>
<p>As an example, consider a hypothetical annotated version of
<code class="docutils literal notranslate"><span class="pre">java.util.List</span></code>:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="nd">@NullMarked</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span> <span class="kd">extends</span> <span class="nd">@Nullable</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="p">(</span><span class="n">E</span> <span class="n">element</span><span class="p">);</span>
  <span class="kd">public</span> <span class="n">E</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, in client code like this:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="nd">@NullMarked</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">foo</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">xs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xs</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// mismatch: add() expects non-null String</span>
  <span class="k">return</span> <span class="n">xs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// compatible: get() returns non-null String</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that (because of the defaulting annotation in effect) both
<code class="docutils literal notranslate"><span class="pre">foo</span></code>’s return type’s and <code class="docutils literal notranslate"><span class="pre">xs</span></code>’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type argument’s are
non-null types. That means that, considering <code class="docutils literal notranslate"><span class="pre">xs</span></code>’s type argument,
<code class="docutils literal notranslate"><span class="pre">xs.add()</span></code>’s expected parameter type is likewise non-null
<code class="docutils literal notranslate"><span class="pre">String</span></code>, as is <code class="docutils literal notranslate"><span class="pre">xs.get()</span></code>’s return type.</p>
<p>Note that unlike with base types, a <code class="docutils literal notranslate"><span class="pre">null</span></code> reference is <em>no longer</em>
automatically assignable to any type:</p>
<ul class="simple">
<li><p>It clearly isn’t usable where a non-null value is required (as in the
example above).</p></li>
<li><p>It also isn’t assignable to types with parametric nullability (since
their type parameters permit non-null instantiations).</p></li>
</ul>
<p>For the latter point, consider the following example:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="nd">@NullMarked</span>
<span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="nd">@Nullable</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">T</span> <span class="n">value</span><span class="p">;</span>

  <span class="kd">public</span> <span class="nf">Box</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>  <span class="c1">// mismatch: T can be instantiated with a non-null qualifier.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Again we do not prescribe how tools handle any of these scenarios, so
tools may be silent or issue lower-priority warnings on source lines
marked “mismatch” here. They’re purely illustrative of how we imagine
tools will apply semantics to expression typing.</p>
</div>
<div class="section" id="the-simplest-thing-that-could-possibly-work-for-subtyping">
<h2>The Simplest(?) Thing That Could Possibly Work for subtyping<a class="headerlink" href="#the-simplest-thing-that-could-possibly-work-for-subtyping" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p class="rubric" id="high-level-overview">High-level overview</p>
<p>It may be that some people will use this doc to guide their
implementations in the near future. Please don’t hesitate to let
cpovirk know of any confusing bits.</p>
<p>I should probably preemptively clarify at least one thing. In this
doc, I have tried to distinguish explicitly between 3 “kinds of
nullability” of a given type usage. Each kind is derived (at least in
part) from the previous:</p>
<ol class="arabic simple">
<li><p>What annotation (if any) appears directly on that type usage?</p></li>
<li><p>What is the <a class="reference external" href="#nullness-operator">nullness operator</a> of that
type usage?</p></li>
<li><p>For that type usage…</p>
<ul class="simple">
<li><p>Is it safe to assume that is not <code class="docutils literal notranslate"><span class="pre">null</span></code>?</p></li>
<li><p>Is it safe to put a <code class="docutils literal notranslate"><span class="pre">null</span></code> into it?</p></li>
<li><p>neither (as in “parametric nullness”)</p></li>
<li><p>both (as in “unspecified nullness” in “lenient mode”)</p></li>
</ul>
</li>
</ol>
<p>TODO(cpovirk): Link to my “Don’t say ‘nullable’” doc once I write it.</p>
</div></blockquote>
</div>
<div class="section" id="references-to-concepts-defined-by-this-spec">
<span id="concept-references"></span><h2>References to concepts defined by this spec<a class="headerlink" href="#references-to-concepts-defined-by-this-spec" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When a rule in this spec refers to any concept that is defined in this
spec (for example, <a class="reference external" href="#substitution">substitution</a> or
<a class="reference external" href="#containment">containment</a>), apply this spec’s definition (as
opposed to other definitions, such as the ones in the JLS).</p>
<p>Additionally, when a rule in this spec refers to a JLS rule that in turn
refers to a concept that is defined in this spec, likewise apply this
spec’s definition.</p>
<p>In particular, when a JLS rule refers to types, apply this spec’s
definition of <a class="reference external" href="#augmented-type">augmented types</a> (as oppposed to
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
types</a>).</p>
</div>
<div class="section" id="nullness-operator">
<h2>Nullness operator<a class="headerlink" href="#nullness-operator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>An nullness operator is one of 4 values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
</ul>
<blockquote>
<div><p>The distinction among these 4 values is similar to the distinction
among the Kotlin types <code class="docutils literal notranslate"><span class="pre">Foo?</span></code>, <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, <code class="docutils literal notranslate"><span class="pre">Foo!</span></code>, and <code class="docutils literal notranslate"><span class="pre">Foo!!</span></code>,
respectively.</p>
</div></blockquote>
</div>
<div class="section" id="augmented-type">
<h2>Augmented type<a class="headerlink" href="#augmented-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>An augmented type consists of a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
and a <a class="reference external" href="#nullness-operator">nullness operator</a> corresponding to <em>each</em>
of its <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.g7gl9fwq1tt5">type
components</a>.</p>
<blockquote>
<div><p>This differs from our current <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=id.367l48xhsikk">glossary
definition</a>,
which is written in terms of a “nullness” for each component, not a
“nullness operator.” Still, the glossary’s concept of the “nullness”
of a type is derivable from the type’s nullness operator. Notably,
the glossary’s “nullable” type is our <a class="reference external" href="#multiple-worlds">least convenient
world</a>’s <a class="reference external" href="#trusted-null-inclusive-under-every-parameterization">trusted null-inclusive under every
parameterization</a>,
and the glossary’s “non-nullable” type is our least convenient
world’s <a class="reference external" href="#trusted-null-exclusive-under-every-parameterization">trusted null-exclusive under every
parameterization</a>.</p>
</div></blockquote>
<p>For our purposes, base types (and thus augmented types) include not just
class and interface types, array types, and type variables but also
<a class="reference external" href="#intersection-types">intersection types</a> and the null type. This is
true even though the JLS sometimes does not supply rules for
intersection types and sometimes has separate rules for the null type.</p>
<p>The goal of this spec is to define rules for augmented types compatible
with those that the JLS defines for base types.</p>
<blockquote>
<div><p>In almost all cases, this spec agrees with the JLS’s rules when
specifying what <em>base</em> types appear in a piece of code. It makes an
exception for <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded
wildcard,”</a> for which it specifies a bound of
<code class="docutils literal notranslate"><span class="pre">Object</span></code> that the JLS does not specify.</p>
</div></blockquote>
<p>When this spec uses capital letters, they refer to augmented types
(unless otherwise noted). This is in contrast to the JLS, which
typically uses them to refer to base types.</p>
<p>When this spec refers to “the nullness operator of” a type <code class="docutils literal notranslate"><span class="pre">T</span></code>, it
refers specifically to the nullness operator of the type component that
is the entire type <code class="docutils literal notranslate"><span class="pre">T</span></code>, without reference to the nullness operator of
any other type components of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<blockquote>
<div><p>For example, the nullness operator of <code class="docutils literal notranslate"><span class="pre">List&lt;&#64;Nullable</span> <span class="pre">Object&gt;</span></code>
would be <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> (at least in a <a class="reference external" href="#null-marked-scope">null-marked
scope</a>), even though the nullness operator of
its element type <code class="docutils literal notranslate"><span class="pre">Object</span></code> is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="null-marked-scope">
<h2>Null-marked scope<a class="headerlink" href="#null-marked-scope" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>To determine whether a type usage appears in a null-marked scope:</p>
<p>Look for an <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.nullness.NullMarked</span></code> annotation on any of
the enclosing scopes surrounding the type usage.</p>
<p>Class members are enclosed by classes, which may be enclosed by other
class members or classes. and top-level classes are enclosed by
packages, which may be enclosed by modules.</p>
<blockquote>
<div><p>Packages are <em>not</em> enclosed by “parent” packages.</p>
</div></blockquote>
<blockquote>
<div><p>This definition of “enclosing” likely matches <a class="reference external" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.compiler/javax/lang/model/element/Element.html#getEnclosingElement()">the definition in the
Java compiler
API</a>.</p>
</div></blockquote>
<p>If an <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.nullness.NullMarked</span></code> annotation exists on one of
these scopes, then the type usage is in a null-marked scope. Otherwise,
it is not.</p>
</div>
<div class="section" id="augmented-type-of-a-type-usage-appearing-in-code">
<span id="augmented-type-of-usage"></span><h2>Augmented type of a type usage appearing in code<a class="headerlink" href="#augmented-type-of-a-type-usage-appearing-in-code" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>For most type usages in source code or bytecode on which JSpecify
nullness annotations are structurally valid, this section defines how to
determine their <a class="reference external" href="#augmented-type">augmented types</a>. Note, however,
that rules for specific cases below take precedence over the general
rule here.</p>
<p>Because the JLS already has rules for determining the <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
for a type usage, this section covers only how to determine its
<a class="reference external" href="#nullness-operator">nullness operator</a>.</p>
<p>To determine the nullness operator, apply the following rules in order.
Once one condition is met, skip the remaining conditions.</p>
<ul class="simple">
<li><p>If the type usage is annotated with
<code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.nullness.Nullable</span></code>, its nullness operator is
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If the type usage appears in a <a class="reference external" href="#null-marked-scope">null-marked
scope</a>, its nullness operator is
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
<li><p>Its nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p></li>
</ul>
<blockquote>
<div><p>The choice of nullness operator is <em>not</em> affected by any nullness
operator that appears in a corresponding location in a supertype. For
example, if one type declares a method whose return type is annotated
<code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>, and if another type overrides that method but does not
declare the return type as <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>, then the override’s return
type will <em>not</em> have nullness operator <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
<p>The rules here never produce the fourth nullness operator,
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>. (It will appear later in
<a class="reference external" href="#substitution">substitution</a>. Additionally, we expect for tool
authors to produce <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> based on the results of null checks
in implementation code.) However, if tool authors prefer, they can
safely produce <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> in any case in which it is equivalent
to <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>. For example, there is no difference between a
<code class="docutils literal notranslate"><span class="pre">String</span></code> with <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> and a <code class="docutils literal notranslate"><span class="pre">String</span></code> with <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="augmented-type-of-an-intersection-type">
<span id="intersection-types"></span><h2>Augmented type of an intersection type<a class="headerlink" href="#augmented-type-of-an-intersection-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>Technically speaking, the JLS does not define syntax for an
intersection type. Instead, it defines a syntax for type parameters
and casts that supports multiple types. Then the intersection type is
derived from those. Intersection types can also arise from operations
like <a class="reference external" href="#capture-conversion">capture conversion</a>. See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.9">JLS
4.9</a>.</p>
<p>One result of all this is that it’s never possible for a programmer
to write an annotation “on an intersection type.”</p>
</div></blockquote>
<p>This spec assigns a <a class="reference external" href="#nullness-operator">nullness operator</a> to each
individual element of an intersection type, following our normal rules
for type usages. It also assigns a nullness operator to the intersection
type as a whole. The nullness operator of the type as a whole is always
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>This lets us provide, for every <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>,
a rule for computing its <a class="reference external" href="#augmented-type">augmented type</a>. But we
require <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> so as to avoid questions like whether “a
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> intersection type whose members are <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>
<code class="docutils literal notranslate"><span class="pre">Foo</span></code> and <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> <code class="docutils literal notranslate"><span class="pre">Bar</span></code>” is a subtype of “a <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>
intersection type with those same members.” Plus, it would be
difficult for tools to output the nullness operator of an
intersection type in a human-readable way.</p>
</div></blockquote>
<blockquote>
<div><p>To avoid ever creating an intersection type with a nullness operator
other than <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, we define special handling for intersection
types under <a class="reference external" href="#applying-operator">“Applying a nullness operator to an augmented
type.”</a></p>
</div></blockquote>
</div>
<div class="section" id="bound-of-an-unbounded-wildcard">
<span id="unbounded-wildcard"></span><h2>Bound of an “unbounded” wildcard<a class="headerlink" href="#bound-of-an-unbounded-wildcard" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In source, an unbounded wildcard is written as <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. This section
does <strong>not</strong> apply to <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, even though that is often
equivalent to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS
4.5.1</a>.</p>
<p>In bytecode, such a wildcard is represented as a wildcard type with an
empty list of upper bounds and an empty list of lower bounds. This
section does <strong>not</strong> apply to a wildcard with any bounds in either list,
even a sole upper bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code>.</p>
<blockquote>
<div><p>For a wildcard with an explicit bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code> (that is,
<code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, perhaps with an annotation on <code class="docutils literal notranslate"><span class="pre">Object</span></code>),
instead apply <a class="reference external" href="#augmented-type-of-usage">the normal rules</a> for the
explicit bound type.</p>
</div></blockquote>
<p>If an unbounded wildcard appears in a <a class="reference external" href="#null-marked-scope">null-marked
scope</a>, then it has a single upper bound whose
<a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose <a class="reference external" href="#nullness-operator">nullness operator</a> is
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
<p>If an unbounded wildcard appears outside a null-marked scope, then it
has a single upper bound whose base type is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose
nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p>
<blockquote>
<div><p>In both cases, we specify a bound that does not exist in the source
or bytecode, deviating from the JLS. Because the base type of the
bound is <code class="docutils literal notranslate"><span class="pre">Object</span></code>, this should produce no user-visible differences
except to tools that implement JSpecify nullness analysis.</p>
</div></blockquote>
<p>Whenever a JLS rule refers specifically to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>, disregard it, and
instead apply the rules for <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">T&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> has a base
type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and the nullness operator defined by this section.</p>
</div>
<div class="section" id="bound-of-an-object-bounded-type-parameter">
<span id="object-bounded-type-parameter"></span><h2>Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter<a class="headerlink" href="#bound-of-an-object-bounded-type-parameter" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In source, an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter can be writen in either
of 2 ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> with no JSpecify nullness type annotations on
the bound</p></li>
</ul>
<p>See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">JLS
4.4</a>.</p>
<p>In bytecode, <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> are both represented as
a type parameter with only a single upper bound, <code class="docutils literal notranslate"><span class="pre">Object</span></code>, and no
JSpecify nullness type annotations on the bound.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears in a <a class="reference external" href="#null-marked-scope">null-marked
scope</a>, then its bound has a <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and a <a class="reference external" href="#nullness-operator">nullness operator</a> of
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>Note that this gives <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> a different bound than <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code> (though
only in a null-marked scope).</p>
</div></blockquote>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears outside a null-marked
scope, then its bound has a base type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and a nullness
operator of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p>
<blockquote>
<div><p>All these rules match the behavior of <a class="reference external" href="#augmented-type-of-usage">our normal
rules</a> for determining the <a class="reference external" href="#augmented-type">augmented
type</a> of the bound <code class="docutils literal notranslate"><span class="pre">Object</span></code>. The only “special”
part is that we consider the source code <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> to have a bound of
<code class="docutils literal notranslate"><span class="pre">Object</span></code>, just as it does when compiled to bytecode.</p>
</div></blockquote>
</div>
<div class="section" id="augmented-null-types">
<span id="null-types"></span><h2>Augmented null types<a class="headerlink" href="#augmented-null-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The JLS refers to “the null type.” In this spec, we assign a <a class="reference external" href="#nullness-operator">nullness
operator</a> to all types, including the null type.
This produces multiple null types:</p>
<ul>
<li><p>the null <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
with nullness operator <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: the “bottom”/“nothing” type
used in <a class="reference external" href="#capture-conversion">capture conversion</a></p>
<blockquote>
<div><p>No value, including <code class="docutils literal notranslate"><span class="pre">null</span></code> itself, has this type.</p>
</div></blockquote>
</li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p>
<blockquote>
<div><p>This is equivalent to the previous type. Tools may use the 2
interchangeably.</p>
</div></blockquote>
</li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>: the type of
the null reference</p></li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code></p>
<blockquote>
<div><p>This may be relevant only in implementation code.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="the-least-convenient-world-and-the-most-convenient-world">
<span id="multiple-worlds"></span><h2>The least convenient world and the most convenient world<a class="headerlink" href="#the-least-convenient-world-and-the-most-convenient-world" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Some of the rules in this spec come in 2 versions, 1 for “the least
convenient world” and 1 for “the most convenient world.”</p>
<p>Tools may implement either or both versions of the rules.</p>
<blockquote>
<div><p>Our goal is to allow tools and their users to choose their desired
level of strictness in the presence of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>. “The least
convenient world” usually assumes that types are incompatible unless
it has enough information to prove they are compatible; “the most
convenient world” assumes that types are compatible unless it has
enough information to prove they are incompatible.</p>
<p>Thus, strict tools may want to implement the least-convenient-world
version of rules, and lenient tools may wish to implement the
most-convenient-world version. Or a tool might implement both and let
users select which rules to apply.</p>
<p>Another possibility is for a tool to implement both versions and to
use that to distinguish between “errors” and “warnings.” Such a tool
might run each check first in the least convenient world and then, if
the check fails, run it again in the most convenient world. If the
check fails in both worlds, the tool would produce an error. If it
passes only because of the most convenient interpretation, the tool
would produce a warning.</p>
</div></blockquote>
<p>The main body of each section describes the <em>least</em>-convenient-world
rule. If the most-convenient-world rule differs, the differences are
explained at the end.</p>
<div class="section" id="propagating-the-most-least-convenient-world">
<span id="propagating-multiple-worlds"></span><h3>Propagating the most/least convenient world<a class="headerlink" href="#propagating-the-most-least-convenient-world" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When one rule in this spec refers to another, it refers to the rule for
the same “world.” For example, when the rules for
<a class="reference external" href="#containment">containment</a> refer to the rules for
<a class="reference external" href="#subtyping">subtyping</a>, the most-convenient-world containment check
applies the most-convenient-world subtyping check, and the
least-convenient-world containment check applies the
least-convenient-world subtyping check.</p>
<p>This applies even if a rule says it is the same for both worlds: It
means “the same except that any other rules are applied in the
corresponding world.”</p>
</div>
</div>
<div class="section" id="same-type">
<h2>Same type<a class="headerlink" href="#same-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> are the same type if <code class="docutils literal notranslate"><span class="pre">S</span></code> is a <a class="reference external" href="#subtyping">subtype</a>
of <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</div>
<div class="section" id="subtyping">
<h2>Subtyping<a class="headerlink" href="#subtyping" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the following conditions are met:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> according to the <a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating
subtyping rules for Java</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a <a class="reference external" href="#nullness-subtyping">nullness subtype</a> of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
</ul>
</div>
<div class="section" id="nullness-delegating-subtyping-rules-for-java">
<span id="nullness-delegating-subtyping"></span><h2>Nullness-delegating subtyping rules for Java<a class="headerlink" href="#nullness-delegating-subtyping-rules-for-java" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Java subtyping rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10">JLS
4.10</a>.
We add to them as follows:</p>
<ul>
<li><p><a class="reference external" href="#concept-references">As always</a>, interpret the Java rules as
operating on <a class="reference external" href="#augmented-type">augmented types</a>, not <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
types</a>.
However, when applying the Java direct-supertype rules themselves,
<em>ignore</em> the <a class="reference external" href="#nullness-operator">nullness operator</a> of the input
types and output types. The augmented types matter only when the Java
rules refer to <em>other</em> rules that are defined in this spec. <em>Those</em>
rules respect the nullness operator of some type components — but
never the nullness operator of the type component that represents the
whole input or output type.</p>
<blockquote>
<div><p>To “ignore” the output’s nullness operator, we recommend
outputting a value of <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, since that is valid for all
types, including <a class="reference external" href="#intersection-types">intersection types</a>.</p>
</div></blockquote>
</li>
<li><p>When the Java array rules require one type to be a <em>direct</em> supertype
of another, consider the direct supertypes of <code class="docutils literal notranslate"><span class="pre">T</span></code> to be <em>every</em>
type that <code class="docutils literal notranslate"><span class="pre">T</span></code> is a <a class="reference external" href="#subtyping">subtype</a> of (as always, applying
the definition of subtyping in this spec).</p></li>
</ul>
</div>
<div class="section" id="nullness-subtyping">
<h2>Nullness subtyping<a class="headerlink" href="#nullness-subtyping" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>The primary complication in subtyping comes from type-variable
usages. Our rules for them must account for every combination of type
arguments with which a given generic type can be parameterized.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a nullness subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if any of the following conditions
are met:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> is <a class="reference external" href="#trusted-null-inclusive-under-every-parameterization">trusted null-inclusive under every
parameterization</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is <a class="reference external" href="#trusted-null-exclusive-under-every-parameterization">trusted null-exclusive under every
parameterization</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a <a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing
path</a> to any type whose base
type is the same as the base type of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
</ul>
<p>Nullness subtyping (and thus subtyping itself) is <em>not</em> transitive.</p>
<p>(Contrast this with our <a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating
subtyping</a> rules and
<a class="reference external" href="#containment">containment</a> rules: Each of those is defined as a
transitive closure. However, technically speaking, <a class="reference external" href="https://groups.google.com/d/msg/jspecify-dev/yPnkx_GSb0Q/hLgS_431AQAJ">there are cases in
which those should not be transitive,
either</a>.
Fortunately, this “mostly transitive” behavior is exactly the behavior
that implementations are likely to produce naturally. Maybe someday we
will find a way to specify this fully correctly.)</p>
<p>Nullness subtyping (and thus subtyping itself) is <em>not</em> reflexive.</p>
<blockquote>
<div><p>It does end up being reflexive in the <a class="reference external" href="#multiple-worlds">most convenient
world</a>. We don’t state that as a rule for 2
reasons: First, it arises naturally from the definitions in that
world. Second, we don’t want to suggest that subtyping is reflexive
in the <a class="reference external" href="#multiple-worlds">least convenient world</a>.</p>
</div></blockquote>
</div>
<div class="section" id="trusted-null-inclusive-under-every-parameterization">
<h2>Trusted null-inclusive under every parameterization<a class="headerlink" href="#trusted-null-inclusive-under-every-parameterization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A type is trusted null-inclusive under every parameterization if it
meets either of the following conditions:</p>
<ul class="simple">
<li><p>Its <a class="reference external" href="#nullness-operator">nullness operator</a> is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>It is an <a class="reference external" href="#intersection-types">intersection type</a> whose elements
all are trusted null-inclusive under every parameterization.</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rule is the same except that the
requirement for “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>” is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="trusted-null-exclusive-under-every-parameterization">
<h2>Trusted null-exclusive under every parameterization<a class="headerlink" href="#trusted-null-exclusive-under-every-parameterization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A type is trusted null-exclusive under every parameterization if it has
a <a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing
path</a> to either of the
following:</p>
<ul>
<li><p>any type whose <a class="reference external" href="#nullness-operator">nullness operator</a> is
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>any augmented class or array type</p>
<blockquote>
<div><p>This rule refers specifically to a “class or array type,” as
distinct from other types like type variables and <a class="reference external" href="#intersection-types">intersection
types</a>.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="nullness-subtype-establishing-path">
<h2>Nullness-subtype-establishing path<a class="headerlink" href="#nullness-subtype-establishing-path" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a nullness-subtype-establishing path to <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the
following hold:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has <a class="reference external" href="#nullness-operator">nullness operator</a> <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p></li>
<li><p>There is a path from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">F</span></code> through
<a class="reference external" href="#nullness-subtype-establishing-direct-supertype-edges">nullness-subtype-establishing direct-supertype
edges</a>.</p>
<blockquote>
<div><p>The path may be empty. That is, <code class="docutils literal notranslate"><span class="pre">A</span></code> has a
nullness-subtype-establishing path to itself — as long as it has
one of the required nullness operators.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirement for “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>” is loosened to
“<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, or <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="nullness-subtype-establishing-direct-supertype-edges">
<h2>Nullness-subtype-establishing direct-supertype edges<a class="headerlink" href="#nullness-subtype-establishing-direct-supertype-edges" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> has nullness-subtype-establishing direct-supertype edges to the
union of the nodes computed by the following 2 rules:</p>
<p>Upper-bound rule:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented <a class="reference external" href="#intersection-types">intersection type</a>:
all the intersection type’s elements whose <a class="reference external" href="#nullness-operator">nullness
operator</a> is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented type variable: all the corresponding type
parameter’s upper bounds whose nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>otherwise: no nodes</p></li>
</ul>
<p>Lower-bound rule:</p>
<ul>
<li><p>for every type parameter <code class="docutils literal notranslate"><span class="pre">P</span></code> that has a lower bound whose <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is the same as <code class="docutils literal notranslate"><span class="pre">T</span></code>’s base type and whose nullness operator is
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: the type variable <code class="docutils literal notranslate"><span class="pre">P</span></code></p>
<p>TODO(cpovirk): What if the lower bound has some other nullness
operator? I’m pretty sure that we want to allow <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> in
the most convenient world (as we did before my recent edits), and we
may want to allow more.</p>
</li>
<li><p>otherwise: no nodes</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirements for “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>” are loosened to
“<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, or <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="containment">
<h2>Containment<a class="headerlink" href="#containment" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS
4.5.1</a>.
We add to them as follows:</p>
<ul>
<li><p>Disregard the 2 rules that refer to a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>. Instead, treat
<code class="docutils literal notranslate"><span class="pre">?</span></code> like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#nullness-operator">nullness
operator</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is specified
by <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>
like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>The rule written specifically for <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code> applies only
if the nullness operator of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>When the JLS refers to the same type <code class="docutils literal notranslate"><span class="pre">T</span></code> on both sides of a rule,
the rule applies if and only if this spec defines the 2 types to be
the <a class="reference external" href="#same-type">same type</a>.</p></li>
</ul>
<p><strong>Most convenient world:</strong> The rules are the same except that the
requirement for “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>” is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</div>
<div class="section" id="substitution">
<h2>Substitution<a class="headerlink" href="#substitution" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>Substitution on Java base types barely requires an explanation: See
<a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-1.html#jls-1.3">JLS
1.3</a>.
Substitution on <a class="reference external" href="#augmented-type">augmented types</a>, however, is
trickier: If <code class="docutils literal notranslate"><span class="pre">Map.get</span></code> returns “<code class="docutils literal notranslate"><span class="pre">V</span></code> with <a class="reference external" href="#nullness-operator">nullness
operator</a> <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>,” and if a user has a
map whose value type is “<code class="docutils literal notranslate"><span class="pre">String</span></code> with nullness operator
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>,” then what does its <code class="docutils literal notranslate"><span class="pre">get</span></code> method return? Naive
substitution would produce “<code class="docutils literal notranslate"><span class="pre">String</span></code> with nullness operator
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> with nullness operator <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.” To reduce
that to a proper augmented type with a single nullness operator, we
define this process.</p>
</div></blockquote>
<p>To substitute each type argument <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code> for each corresponding type
parameter <code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>:</p>
<p>For every type-variable usage <code class="docutils literal notranslate"><span class="pre">V</span></code> whose <a class="reference external" href="https://docs.google.com/document/d/1KQrBxwaVIPIac_6SCf--w-vZBeHkTvtaqPSU_icIccc/edit#bookmark=kix.k81vs7t5p45i">base
type</a>
is <code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>, replace <code class="docutils literal notranslate"><span class="pre">V</span></code> with the result of the following operation:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">V</span></code> is <a class="reference external" href="#trusted-null-exclusive-under-every-parameterization">trusted null-exclusive under every
parameterization</a>
in the <a class="reference external" href="#multiple-worlds">least convenient world</a>, then replace it
with the result of <a class="reference external" href="#applying-operator">applying</a> <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>
to <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code>.</p>
<blockquote>
<div><p>This is the one instance in which a rule references another rule
to be run under a <em>different</em> “world.” Normally, all rules are run
<a class="reference external" href="#propagating-multiple-worlds">under the same “world.”</a> But in
this instance, the null-exclusivity rule (and all rules that it in
turn applies) are always run in the least convenient world.</p>
</div></blockquote>
<blockquote>
<div><p>This special case improves behavior in “the
<code class="docutils literal notranslate"><span class="pre">ImmutableList.Builder</span></code> case”: Consider an unannotated user of
that class. Its builder will have an element type whose <a class="reference external" href="#nullness-operator">nullness
operator</a> is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>. Without this
special case, <code class="docutils literal notranslate"><span class="pre">builder.add(objectUnionNull)</span></code> would pass the
subtyping check in the <a class="reference external" href="#multiple-worlds">most convenient
world</a>. This would happen even though we have
enough information to know that the parameter to <code class="docutils literal notranslate"><span class="pre">add</span></code> is
universally null-exclusive — even in the most convenient world.
The special case here makes that subtyping check fail.</p>
</div></blockquote>
</li>
<li><p>Otherwise, replace <code class="docutils literal notranslate"><span class="pre">V</span></code> with the result of applying the nullness
operator of <code class="docutils literal notranslate"><span class="pre">V</span></code> to <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code>.</p></li>
</ul>
</div>
<div class="section" id="applying-a-nullness-operator-to-an-augmented-type">
<span id="applying-operator"></span><h2>Applying a nullness operator to an augmented type<a class="headerlink" href="#applying-a-nullness-operator-to-an-augmented-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The process of applying a <a class="reference external" href="#nullness-operator">nullness operator</a>
requires 2 inputs:</p>
<ul class="simple">
<li><p>the nullness operator to apply</p></li>
<li><p>the <a class="reference external" href="#augmented-type">augmented type</a> (which, again, includes a
<a class="reference external" href="#nullness-operator">nullness operator</a> for that type) to apply it
to</p></li>
</ul>
<p>The result of the process is an augmented type.</p>
<p>The process is as follows:</p>
<p>First, based on the pair of nullness operators (the one to apply and the
one from the augmented type), compute a “desired nullness operator.” Do
so by applying the following rules in order. Once one condition is met,
skip the remaining conditions.</p>
<ul class="simple">
<li><p>If the nullness operator to apply is <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, the desired
nullness operator is <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p></li>
<li><p>If either nullness operator is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>, the desired nullness
operator is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If either nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>, the desired nullness
operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p></li>
<li><p>The desired nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
</ul>
<p>Then, if the input augmented type is <em>not</em> an <a class="reference external" href="#intersection-types">intersection
type</a>, the output is the same as the input but
with its nullness operator replaced with the desired nullness operator.</p>
<p>Otherwise, the output is an intersection type. For every element <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code>
of the input type, the output type has an element that is the result of
applying the desired nullness operator to <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code>.</p>
<blockquote>
<div><p>In this case, the desired nullness operator is always equal to the
nullness operator to apply that was an input to this process. That’s
because the nullness operator of the intersection type itself is
defined to always be <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="capture-conversion">
<h2>Capture conversion<a class="headerlink" href="#capture-conversion" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">JLS
5.1.10</a>.
We add to them as follows:</p>
<ul>
<li><p>The parameterized type that is the output of the conversion has the
same <a class="reference external" href="#nullness-operator">nullness operator</a> as the parameterized
type that is the input type.</p></li>
<li><p>Disregard the JLS rule about <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. Instead, treat <code class="docutils literal notranslate"><span class="pre">?</span></code> like
<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#nullness-operator">nullness
operator</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is specified
by <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>
like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>When a rule generates a lower bound that is the null type, we specify
that its nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>. (See <a class="reference external" href="#null-types">“Augmented null
types.”</a>)</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="index.html" class="btn btn-neutral float-left" title="JSpecify: 静的解析のための標準化されたJavaアノテーション" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2018-2021, The JSpecify Authors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>